CREATE OR REPLACE FUNCTION P_GET_RECIPIENT_SUMM_YEAR_HYBR
(
  P_CONTRACT_        IN NUMBER,
  DATE_              IN DATE,
  SUMM_REMAIN_       IN NUMBER, -- ОСТАТОК НА ИПС, передается в любом случае и для ВИПои и не для ВИПов если эта функция вызывается при создании графика
                          --  ели эта функция вызывается из другого места - то передается NULL
  IS_VIP_           OUT PLS_INTEGER, -- ВЫХОДНОЙ ПАРАМЕТР ПРИЗНАК ВИПа
  P_CLAIM_PAY_OUT_   IN NUMBER default null, -- ID-ЗАЯВЛЕНИЯ ПО КОТОРОМУ ЗАПРАШИВАЕТСЯ ГОДОВАЯ СУММА ПОЛОЖЕННАЯ ВКЛАДЧИКУ. ПЕРЕДАЕТСЯ ЛЮБОЙ ВИД ЗАЯВЛЕНИЯ 1-ОБЫЧНОЕ РАЗОВОЕ ЗАЯВЛЕНИЕ, 4-ДОП. СОГЛ., 2-ИЗМ БАНК.РЕКВ/УСТРАНЕННИЕ КЗ
                              -- В ЛЮБОМ СЛУЧАЕ БУДЕТ БРАТЬСЯ НАЧАЛЬНОЕ РОДИТЕЛЬСКОЕ ЗАЯВЛЕНИЕ С ТИПОМ = 1
  IS_VIRTUAL_        IN NUMBER DEFAULT 0, -- ПРИЗНАК, ЧТО В ФУНКИЮ В КАЧЕСТВЕ SUMM_REMAIN_ ПЕРЕДАЕТСЯ ВИРТУАЛЬНЫЙ ОСТАТОК, КОТОРЫЙ БУДЕТ У ВКЛАДЧИКА В БУДУЩИХ ГОДАХ
  IGNORE_REMAIN_     IN PLS_INTEGER DEFAULT 0, -- 0-НЕ ОБРЕЗАТЬ, ВОЗВРАЩАТЬ ГОДОВУЮ СУММУ ПО ЗАКОНУ, ДАЖЕ ЕСЛИ ОСТАТОК МЕНЬШЕ НЕЁ (РАНЬШЕ ЭТО БЫЛО В ПАРАМЕТРЕ IS_VIP_=-1) 1- ОБРЕЗАТЬ ГОДОВУЮ СУММУ, ЕСЛИ ОНА МЕНЬШЕ ОСТАТКА,
  ARR_MIN_PENS_     OUT ARR_MIN_PENS_TYPE,
  VIP_KOEF_         OUT NUMBER, -- КОЭФФИЦИЕНТ ВКЛАДЧИКА ПО ВОЗРАСТУ, НУЖЕН ДЛЯ СОХРАНЕНИЯ В P_GRF И ОТОБРАЖЕНИЯ В МОДУЛЕ КЛИЕНТЫ
  IS_OLD_ALGORITHM_  IN NUMBER, -- ПРИЗНАК ОБРАБОТКИ ЗАЯВЛЕНИЯ ПО СТАРОМУ ЗАКОНОДАТЕЛЬСТВУ, ДЕЙСТВУЮЩЕГО ДО 2018, ЕСЛИ 1 - ТО ПО СТАРОМУ ЗАКОНОДАТЕЛЬСТВУ, 0 - ПО НОВОМУ
  SUM_TAX_DEFERRAL_  IN NUMBER DEFAULT 0,
  ERR_CODE          OUT NUMBER,
  ERR_MSG           OUT VARCHAR2
) RETURN NUMBER
IS
/*  ФУНКЦИЯ ДЛЯ ВЫЧИСЛЕНИЯ ГИБРИДНОЙ ГОДОВОЙ СУММЫ, НОВАЯ ВЕРСИЯ, С ДОРАБОТКАМИ ПО 5-ТИ СЛУЧАЯМ ПО АХАНОВУ

    Функция вычисляет максимальную годовую сумму положенную вкладчику, c учетом предыдущих заявлений, нужных для вычисления вип-а
    Функция вызывается из трех мест:
    1) Из процедуры построения графика P_CALC_GRF - в этом случае в качестве параметра P_CLAIM_PAY_OUT передается ID Доп.Соглашения
    2) При создании нового любого заявления на выплату и значение результата этой функции вставляется в поле P_CLAIM_PAY_OUT AMOUNT, при этом в качестве входного параметра P_CLAIM_PAY_OUT_ передается NULL
    3) При осуществлении разовых выплаты в модуле ДУиОПА (ОПЕРАЦИИ), при этом в качестве параметра передается ID самого заявления с типом 1 или 2

    ОПРЕДЕЛЕНИЕ СОСТОЯНИЯ ВИПа И ОСТАТОК НА НАЧАЛО ГОДА ОПРЕДЕЛЯЕТСЯ СЛЕДУЮЩИМ ОБРАЗОМ:
    ПО ЗАДАЧЕ №12572 В БИТРИКСЕ И ЗАДАЧА #6834 НА САЙТЕ ТЕХ.ПОДДЕРЖКИ БСБ ВЫСТАВЛЕНЫ ТРЕБОВАНИЯ:
    1) Получатель с крупной суммой ПН подал заявление о назначении пенсионных выплат в связи с достижением пенсионного возраста (далее - заявление) первый раз в Фонд, т.е. других заявлений не было -
       сумма первой выплаты по первичному заявлению рассчитывается, как сумма ПН на дату подачи заявления умноженная на коэффициент текущей стоимости ПН в соответствующем возрасте получателя,
       и делится на оставшееся количество выплат в текущем календарном году в соответствии с периодичностью, указанной в заявлении.
    2) Получатель с крупной суммой ПН подал новое заявление, но у него есть другое заявление за прошлый год, но нет выплат в текущем году -
       сумма первой выплаты по новому заявлению рассчитывается, как сумма ПН на дату подачи нового заявления в текущем году умноженная на коэффициент текущей стоимости ПН на возраст получателя в текущем году,
       и делится на оставшееся количество выплат в текущем году в соответствии с периодичностью, указанной в заявлении.
    3) Получатель с крупной суммой ПН подал новое заявление, но у него есть другое заявление за прошлый год, и есть выплаты по нему в текущем году -
       для расчета суммы первой выплаты по новому заявлению, берется годовая сумма выплаты, рассчитанная на дату первой выплаты в текущем календарном году*, вычитаются суммы осуществленных в текущем календарном году пенсионных выплат,
       и делится на оставшееся количество выплат в соответствии с периодичностью, указанной в новом заявлении.
    4) Получатель с крупной суммой ПН подал новое заявление, но у него есть другое заявление в текущем году, но нет выплат в текущем году (это возможно только если заявление аннулировано или возвращено, т.е. заявление не является активным) -
       сумма первой выплаты по новому заявлению рассчитывается, как сумма ПН на дату подачи нового заявления умноженная на коэффициент текущей стоимости ПН на возраст получателя в текущем календарном году,
       и делится на оставшееся количество выплат в соответствии с периодичностью, указанной в новом заявлении.
    5) Получатель с крупной суммой ПН подал новое заявление, но у него есть другое заявление в текущем году, и есть выплаты в текущем году -
       для расчета суммы первой выплаты по новому заявлению, берется годовая сумма выплаты, рассчитанная на дату первой выплаты в текущем календарном году*, вычитаются суммы осуществленных в текущем календарном году пенсионных выплат,
       и делится на оставшееся количество выплат в соответствии с периодичностью, указанной в новом заявлении.
    Уточнение по этим 5-ти случаям: если заявление подали в ГК - то в тех пунктах где говорится что сумма ПН расчитывается на дату подачи заявления надо считать на дату первой выплаты.
    Это случаи 1, 2 и 4. Таким образом получается - что во всех 5-ти случаях сумма ПН будет браться на дату первой выплаты. Поэтому проще было для заявлений поданных в ГК написать отдельное условие.

    Логика работы
    если V_COUNT_YEAR_CLAIM_WITH_ > 0 OR P_CLAIM_PAY_OUT_ IS NULL -- заявление подали в текущем году
    1) если параметр IS_VIP <> -1, то остаток надо вычислить заново (вообще в процедуру в качестве остатка передать NULL)
    1.1) если V_COUNT_CLAIM_BEFORE_ = 0 и V_COUNT_YEAR_CLAIM_ = 0 - то есть случай 1 из заявки
    1.1.1) если новый входящий параметр P_CLAIM_PAY_OUT is null (вызов до существования заявления у Айдына), то остаток брать на текущую опер дату;
    1.1.2) если новый входящий параметр P_CLAIM_PAY_OUT is not null, то остаток брать из заявления (и у Серика и у меня);
    1.2) если V_COUNT_CLAIM_BEFORE_  > 0 и V_COUNT_YEAR_CLAIM_=0 и V_COUNT_YEAR_PAYMENTS_=0 - то есть случай 2 из заявки
    1.2.1) если новый входящий параметр P_CLAIM_PAY_OUT is null (вызов до существования заявления у Айдына), то остаток брать на текущую опер дату;
    1.2.2) если новый входящий параметр P_CLAIM_PAY_OUT is not null, то остаток брать из заявления (и у Серика и у меня);
    1.3) если V_COUNT_CLAIM_BEFORE_  > 0 и V_COUNT_YEAR_CLAIM_=0 и V_COUNT_YEAR_PAYMENTS_>0 - то есть случай 3 из заявки
             - то остаток брать на дату первой выплаты в текущем году независимо от заявления
    1.4) если V_COUNT_YEAR_CLAIM_>0 и V_COUNT_YEAR_PAYMENTS_=0 - то есть случай 4 из заявки
    1.4.1) если новый входящий параметр P_CLAIM_PAY_OUT is null (вызов до существования заявления у Айдына), то остаток брать на текущую опер дату;
    1.4.2) если новый входящий параметр P_CLAIM_PAY_OUT is not null, то остаток брать из заявления (и у Серика и у меня);
    1.5) если V_COUNT_YEAR_CLAIM_>0 и V_COUNT_YEAR_PAYMENTS_>0 - то есть случай 5 из заявки
             - то остаток брать на дату первой выплаты в текущем году независимо от заявления

    иначе
    1.6)  во всех остальных случаях без условия означает график строится по существующему заявлению, которое было введено в прошлом году или ранее
    1.6.1) если V_COUNT_YEAR_ALL_PAYMENTS_ = 0, то остаток брать на текущую опер дату;
    1.6.2) если V_COUNT_YEAR_ALL_PAYMENTS_ > 0, то остаток брать на дату первой выплаты в текущем году;



    Максимальная годовая сумма пенсионных выплат рассчитывается в размере
    наибольшей из следующих величин:
    1)  тридцатикратного размера минимальной пенсии (размер минимальной пенсии должен задаваться
        в справочнике, справочник должен быть историческим);
    2)  двухсот пятидесяти тысяч тенге;
    3)  величины, рассчитанной как произведение суммы пенсионных накоплений
        на коэффициент текущей стоимости в соответствующем возрасте получателя
        согласно таблице

*/

  -- История изменений:
  -- Дата        Кто             Comments  где изменялось
  -----------------------------------------------------------------------------------------------------------------------------------------------
  -- 07.03.2019  Sarsenbaev Baurzhan  Доработка по заявке №19507 по сопровождению. Если это заявление создано автоматически Айдыном как заявление на довыплату (то есть в номере заявления присуствует фраза "ДВ_график")
  --                                  то сравнение с 12 МЗП проводить не надо. Поэтому в конец условия IF добавил AND INSTR(LOWER(Rec_claim.CLAIM_NUM),'дв_график') = 0
  -- 07.11.2018  Sarsenbaev Baurzhan  Доработка по заявке №19507 по сопровождению. В блоке 29 переделал чтобы при вычислении суммы пенсионных накоплений курс у.е. брался на предыдущий операицонный день (а не текущий)
  -- 25.09.2018  Sarsenbaev Baurzhan  Доработка по заявке №5 о определении суммы выплаты на дату обращения для заявлений по новому законодательству
  --              Добавлены новые блоки 26, 27, 28, 29
  -- 28.11.2017  Omirbaev Timur  Доработка по новому законодательству
  -- 03.05.2020:  МАМЕТОВ СЕРИК АЛИМАМЕТОВИЧ: ПО ЗАДАЧЕ №508960 ДЛЯ ДО ВЫПЛАТ ОСТАТОК ДОЛЖЕН СЧИТАТЬСЯ НА ТЕКУЩУЙ МОМЕНТ А НЕ НА МОМЕНТ ПОДАЧИ ЗАЯВЛЕНИЯ

  -- 19-11-2020: МАМЕТОВ СЕРИК АЛИМАМЕТОВИЧ: ПО РАБОТЕ С ИЗЪЯТИЯМИ ПН НА УЛУЧШЕНИЕ ЖИЗНЕННЫ УСЛОВИИ ПОЯВИЛОСЬ ПОНЯТИЕ ОТЛОЖЕННЫЙ ИПН. ЭТО
  -- ОЗНАЧАЕТ, ЧТО ИПН БУДЕТ УДЕРЖИВАТЬСЯ НЕ СРАЗУ НА МОМЕНТ ИЗЪЯТИЯ, А ПОЗЖЕ, ПРИ ВЫХОДЕ НА ПЕНСИЮ И ЕЩЕ В ТЕЧЕНИИ 16 ЛЕТ.
  -- РЕШЕНИЕ ПРАВИТЕЛЬСТВА СТРАНЫ КОНЕЧНО ОГОНЬ ЕПРСТ....ПОЭТОМУ ПРИ ПОСТРОЕНИИ ПЛАН ГРАФИКА ОСТАТОК НА ИПС НУЖНО ПОКАЗАТЬ ЗА МИНУСОМ СУММЫ
  -- ЗАДОЛЖЕННОСТИ ОТЛОЖЕННОГО ИПН. СУММУ ОТЛОЖЕННОГО ИПН БУДЕТ УДЕРЖИВАТЬСЯ ВСЕГДА ПЕРЕД ОСНОВНОЙ ВЫПЛАТОЙ
  -- ДОБАВИЛ ВХОДЯЩИЙ ПАРАМЕТР SUM_TAX_DEFERRAL_ - СУММА ОТЛОЖЕНОГО ИПН

  -- 04-01-2021: МАМЕТОВ СЕРИК АЛИМАМЕТОВИЧ: ПОСЛЕ РАЗЪЯСНЕНИИ КГД КАСАТЕЛЬНО УЧЕТА ОТЛОЖЕННОГО ИПН ИЗМЕНИЛИСЬ РАСЧЕТЫ, ИЗМЕНИЛСЯ ПОДХОД К УЧЕТУ ОТЛОЖЕННОГО ИПН

  -- 06-03-2021: МАМЕТОВ СЕРИК АЛИМАМЕТОВИЧ: ПО ЗАДАЧЕ В БИТРИКСЕ № 599199 РАЗРАБОТКА И РЕАЛИЗАЦИЯ ФУНКЦИОНАЛА ПО РАСЧЕТУ РАЗМЕРА ПЕНСИОННЫХ ВЫПЛАТ
  -- В СООТВЕТСТВИИ С МЕТОДИКОЙ ОСУЩЕСТВЛЕНИЯ РАСЧЕТА РАЗМЕРА ПЕНСИОННЫХ ВЫПЛАТ

  -- 19-08-2021: МАМЕТОВ СЕРИК АЛИМАМЕТОВИЧ: ПО ЗАДАЧЕ В БИТРИКСЕ № 669146 ТЕПЕРЬ ТРЕБУЕТСЯ ОТМЕНА УСЛОВИЯ НИЖЕ
  -- 1.    Департамент учета и отчетности пенсионных активов (Байгалиева З.Ж.):
  -- 1) с даты подписания акта о завершении работ и приемки в промышленную эксплуатацию доработки ИАИС-2 вкладчикам (получателям), реализовавшим свое право на пенсионные выплаты
  -- из ЕНПФ до 1 января 2018 года, пенсионные выплаты с периодичностью «ежегодно» рассчитывать согласно Методике 1, действовавшей на момент принятия заявлений
  -- о назначении пенсионных выплат, в следующем порядке:
  -- сумма годовой пенсионной выплаты рассчитывается и не превышает наибольшую из
  -- тридцатикратного размера минимальной пенсии, установленного на соответствующий финансовый год законом о республиканском бюджете;
  -- величины, рассчитанной как произведение суммы пенсионных накоплений на коэффициент текущей стоимости пенсионных накоплений в соответствующем
  -- возрасте получателя согласно Методике;
  -- 25.02.2022  Бычков               для довыплат по распоряжениям 2022+ года, добавлен учет нового законодательства
  -- 30.09.2023  Тайканов Е.Р.        Задача КП Битрикс № 933477. По задаче если на момент расчета выплаты остаток на счете менее 12 МинПенсии, то выплачиваем весь остаток. Раньше брали остаток на дату заявления.
  -- 27.11.2024  Тайканов Е.Р.        Задача КП Битрикс https://enpf24.kz/company/personal/user/115/tasks/task/view/1087909/  Теперь берем всеь остаток с учетом УИП
  --                                  Опимизировал некоторый код.
  ------------------------------------------------------------------------------------------------------------------------------------------------


  PROCNUM                       CONSTANT TYPES.TPROC_NAME := 'P_GET_RECIPIENT_SUMM_YEAR';
  RESULT                        NUMBER;
  V1_                           NUMBER;
  V2_                           NUMBER;
  V3_                           NUMBER;
  AGE_                          NUMBER;
  V_COUNT                       NUMBER;
  P_G_CLAIM_PAY_OUT_KND_        NUMBER;
  V_P_CLAIM_PAY_OUT_            NUMBER;
  V_COUNT_CLAIM_BEFORE_         NUMBER; --количество заявлений (кроме наследников, погребение, выезд за границу, по решению суда) с типом заявления = 1 за предыдущие года. Есть ли хоть одно другое(не совпадает ID) заявление с неошибочным статусом не зависимо открыто или закрыто, у которого существует ДС, но год даты регистрации которого строго меньше года входящего параметра
  V_COUNT_YEAR_CLAIM_           NUMBER; --количество заявлений (кроме наследников, погребение, выезд за границу, по решению суда) с типом заявления = 1 в текущем году. Есть ли хоть одно другое(не совпадает ID) заявление с неошибочным статусом не зависимо открыто или закрыто, у которого существует ДС, но год даты регистрации которого совпадает с годом входящего параметра
  V_COUNT_YEAR_PAYMENTS_        NUMBER; --количество выплат по заявлениям (кроме наследников, погребение, выезд за границу, по решению суда) с типом заявления = 1 в текущем году по другим заявлениям (то есть исключая ID данного заявления). Можно вычислить из P_PAYMENT_INFO год из даты периода совпадает с годом входящего параметра с статусом 1
  V_COUNT_YEAR_ALL_PAYMENTS_    NUMBER; --количество выплат заявлениям (кроме наследников, погребение, выезд за границу, по решению суда) с типом заявления = 1 в текущем году независимо от заявления. То есть вычисляется точно так же как переменная V_COUNT_YEAR_PAYMENTS_ но только надо убрать условие исключая ID данного заявления
  V_COUNT_YEAR_CLAIM_WITH_      NUMBER; --количество заявлений (кроме наследников, погребение, выезд за границу, по решению суда) с типом заявления = 1 в текущем году включая это заявление тоже. Определяется как переменная V_COUNT_YEAR_CLAIM_, единственно надо убать условия что не должно совпадать ID заявления
  V_SUMM_                       NUMBER;
  V_SUMREMAIN_FROM_CLAIM_       NUMBER;
  V_DATE_FIRST_PAY_YEAR_        DATE;
  V_P_OPR2_                     NUMBER;
  V_P_PAYMENT_INFO_             NUMBER;
  CNT_FUETURE_MIN_PENS_         NUMBER;

  BLOCK_                        VARCHAR2(255);
  MIN_PENS_VALUE_               NUMBER;
  MIN_PENS_DATE_                DATE;
  MIN_PENS_ID_                  NUMBER;

  BASE_DATE_                    DATE;
  CNT_MIN_PENS_                 NUMBER;
  V_I                           NUMBER;

  TMP_MIN_PENS_ID_              NUMBER;
  TMP_MIN_PENS_VAL_             NUMBER;
  TMP_MIN_PENS_MONTH_BEGIN_     NUMBER;
  TMP_MIN_PENS_MONTH_END_       NUMBER;
  CURRENT_WORKING_DATE_         DATE;

  IS_HAVE_RIGHT_REG_OLD_LAW_    NUMBER;
  P_G_REGISTRATION_TYPE_        NUMBER;
  p_g_pay_out_type_             NUMBER;
  date_registr_                 DATE;
  v_count_payed_claim_all       NUMBER;
  v_p_claim_pay_out_initial     NUMBER;
  v_date_1                      DATE;
  v_date_2                      DATE;
  v_current_sum_remain          NUMBER;
  V_COUNT_PAY_YEAR_THIS_CLAIM   number;
  v_WORKING_DATE                number;
  v_WORK_DATE                   DATE;
  V_IS_ON_OPER_CLAIM_DATE       number := 0; --Сарсенбаев Б.О. 21.09.2018 Признак что пенсионные накопления для вычисляения суммы выплаты должны браться на операционную а не календарную дату подачи заявления.
  V_WORKING_DATE_FIRST_PAY      number; --Сарсенбаев Б.О. 21.09.2018 ID операционной даты первой выплаты по данному заявлению вообще
  V_WORK_DATE_FIRST_PAY         DATE; --Сарсенбаев Б.О. 21.09.2018 Операционная дата первой выплаты по данному заявлению вообще
  DATE_CONTACT_                 DATE; --Сарсенбаев Б.О. 21.09.2018 дата обращения вкладчика
  DATE_RECEPTION_               main.p_claim_pay_out.DATE_RECEPTION%type; -- Сарсенбаев Б.О. 25.09.2018: Заявка №5 о определении суммы выплаты на дату обращения для заявлений по новому законодательству
                                                                       -- в этом поле для заявлений по новому законодательству хранится дата обращения вкладчика
  MIN_PENS_ON_DATE_CONCTACT_    NUMBER; -- значение минимальной пенсии на операционную дату обращения вкладчика

  --(!) CLAIM_NUM_                    P_CLAIM_PAY_OUT$$O.CLAIM_NUM%TYPE;-- Сарсенбаев Б.О, Маметов С. 07.03.2019г. номер заявления нужен для того, чтобы определить это заявление на довыплату или нет
  CLAIM_NUM_                    P_CLAIM_PAY_OUT.CLAIM_NUM%TYPE;-- Сарсенбаев Б.О, Маметов С. 07.03.2019г. номер заявления нужен для того, чтобы определить это заявление на довыплату или нет
  IS_PAY_EXTRA_                 NUMBER := 0;-- МАМЕТОВ С.А. ПРИЗНАК, ЧТО ВЫПЛАТА ЯВЛЯЕТСЯ ДО ВЫПЛАТОЙ

  PAYOUT_RATE_                  NUMBER := 6.5; -- СТАВКА ВЫПЛАТ ПЕНСИОННЫХ НАКОПЛЕНИЙ В %
  G_TYPE_PERIOD_                NUMBER;
  p_g_Pay_Out_Sub_Type_         NUMBER;
  V_ERR_CODE                    TYPES.TERR_CODE;
  V_ERR_MSG                     TYPES.TERR_MSG;

  FUNCTION GET_MIN_PENSION_SUMM_IN_YEAR(MIN_PENS_DATE_ DATE) RETURN NUMBER
  IS
    RESULT NUMBER;
  BEGIN
        SELECT G.VALUE
          INTO RESULT
          FROM G_MINIMAL_DESIGN_INDEX G
         WHERE G.G_PARAMETER = 2 AND
               G.K_DAY = (SELECT MAX(G2.K_DAY)
                            FROM G_MINIMAL_DESIGN_INDEX G2
                           WHERE G2.G_PARAMETER = 2
                             AND G2.K_DAY <= MIN_PENS_DATE_
                           );

        RETURN(RESULT);
  END GET_MIN_PENSION_SUMM_IN_YEAR;

BEGIN
   BLOCK_ := '01a';
   BEGIN
     IF P_CLAIM_PAY_OUT_ IS NOT NULL THEN
       SELECT  NVL(C.IS_HAVE_RIGHT_REG_OLD_LAW, 0) -- (27.11.2017) по доработке нового алгоритма графика(только ежемесячные и )
              ,NVL(C.P_G_REGISTRATION_TYPE,1)  -- (13.06.2018) по доработке ЗАЯВКА НА РАЗВИТИЕ №3 пЕРЕДАЧА ВЫПЛАТ В ГК
              ,st.p_g_pay_out_type -- Сарсенбаев Б.О. 21.09.2018 На всякий случай вычисляю вид выплаты, на данный момент не играет роли, но вдург понадобиться в будущем
              ,TRUNC(DECODE(C.P_G_REGISTRATION_TYPE,4,C.DATE_RECEPTION,C.DATE_REGISTR)) -- Сарсенбаев Б.О. 21.09.2018 На всякий случай вычисляю дату приема заявления, на данный момент не играет роли, но вдруг понадобиться в будущем
              ,C.p_claim_pay_out_initial
              ,c.DATE_RECEPTION -- Сарсенбаев Б.О. 25.09.2018: Заявка №5 о определении суммы выплаты на дату обращения для заявлений по новому законодательству. В этом поле для заявлений по новому законодательству хранится дата обращения вкладчика
              ,c.CLAIM_NUM
              ,NVL(C.IS_PAY_EXTRA, 0)
              ,C.G_TYPE_PERIOD
              
              ,C.P_G_CLAIM_PAY_OUT_KND
              ,C.SUMREMAIN
              ,CASE 
                 WHEN 
                   C.P_G_CLAIM_PAY_OUT_KND != 1 
                 THEN 
                   C.P_CLAIM_PAY_OUT_INITIAL
                 ELSE
                   C.P_CLAIM_PAY_OUT
               END
               , c.p_g_Pay_Out_Sub_Type
         INTO IS_HAVE_RIGHT_REG_OLD_LAW_, P_G_REGISTRATION_TYPE_, p_g_pay_out_type_, DATE_REGISTR_,
              v_p_claim_pay_out_initial, DATE_RECEPTION_, CLAIM_NUM_, IS_PAY_EXTRA_, G_TYPE_PERIOD_
              ,P_G_CLAIM_PAY_OUT_KND_, V_SUMREMAIN_FROM_CLAIM_, V_P_CLAIM_PAY_OUT_
              , p_g_Pay_Out_Sub_Type_
         FROM MAIN.P_CLAIM_PAY_OUT C, --(!) FROM MAIN.P_CLAIM_PAY_OUT$$O C,
              MAIN.P_G_PAY_OUT_SUB_TYPE st
        WHERE C.P_CLAIM_PAY_OUT = P_CLAIM_PAY_OUT_
          AND C.P_G_PAY_OUT_SUB_TYPE = st.P_G_PAY_OUT_SUB_TYPE;-- Сарсенбаев Б.О. 17.07.2018 Теперь надо определить является ли заявление на выплату инвалидам, так как они обрабатываются как заявления на выплату через ГК (Задача в битриксе №211186) поэтому добавил этот код
     ELSIF IS_OLD_ALGORITHM_ IS NOT NULL THEN
       IS_HAVE_RIGHT_REG_OLD_LAW_ := IS_OLD_ALGORITHM_;
     ELSE
       BLOCK_ := BLOCK_ || ' Не удалось определить по какому законодательству считать годовую сумму, до 2018 или с 2018';
       RAISE ADM.TYPES.E_Force_Exit;
     END IF;
     IF P_CLAIM_PAY_OUT_ IS NULL THEN
       -- 15.06.2018 по доработке ЗАЯВКА НА РАЗВИТИЕ №3 пЕРЕДАЧА ВЫПЛАТ В ГК
       -- Заявления еще нет, Айдын в этом случае признак что это заявление создано в ГК пихает в пакетную переменную PENSION_PACK.P_Claim_Is_Created_By_Gk = 1
       IF PENSION_PACK.P_Claim_Is_Created_By_Gk = 1 THEN
          P_G_REGISTRATION_TYPE_ := 4;
       ELSIF PENSION_PACK.P_Claim_Is_Created_By_Gk = 0 THEN
          P_G_REGISTRATION_TYPE_ := 1;
       ELSIF P_G_REGISTRATION_TYPE_ IS NULL THEN
         /*PENSION_PACK.P_Claim_Is_Created_By_Gk := 0;
         P_G_REGISTRATION_TYPE_ := 1;
         IS_HAVE_RIGHT_REG_OLD_LAW_ := 0;
         PENSION_PACK.p_g_pay_out_type := 8;*/

         BLOCK_ := BLOCK_ || ' Не удалось определить способ регистрации заявления!';
         RAISE ADM.TYPES.E_Force_Exit;
       END IF;
       -----------------------------
       -- 17.07.2018 Задача в битриксе №211186
       -- Теперь надо определить является ли заявление на выплату инвалидам, так как они обрабатываются как заявления на выплату через ГК
       -- Заявления еще нет, Айдын в этом случае признак что это заявление на выплату инвалидам пихает в пакетную переменную PENSION_PACK.p_g_pay_out_type
       IF IS_HAVE_RIGHT_REG_OLD_LAW_ = 0 THEN -- эту пакетную переменную Айдын заполняет только в том случае, если это заявление на выплдату по новому законодательству
         IF PENSION_PACK.p_g_pay_out_type IS NOT NULL THEN
            p_g_pay_out_type_ := PENSION_PACK.p_g_pay_out_type;
         ELSE
           BLOCK_ := BLOCK_ || ' Не удалось определить вид выплаты!';
           RAISE ADM.TYPES.E_Force_Exit;
         END IF;
       END IF;
       -----------------------------
       date_registr_ := TRUNC(sysdate); --17.07.2018 Если заявление только создают, то датой регистрации заявления является текущая системная дата
       DATE_RECEPTION_ := TRUNC(sysdate); --25.09.2018 Если заявление только создают, то датой приема заявления является текущая системная дата
     END IF;
   END;

   BLOCK_ := '01b';
   SELECT A.WORKING_DATE, A.WORK_DATE
     INTO v_WORKING_DATE, v_WORK_DATE
     FROM V_CURRENT_WORKING_DATE A
    WHERE ROWNUM = 1;

   BLOCK_ := '01c';
   -- ЕСЛИ СНАРУЖИ ПЕРЕДАЛИ ПРИЗНАК ВИРТУАЛЬНОГО ОСТАТКА, ТО ВЫЧИСЛЯТЬ НА НАЧАЛО ГОДА НЕ НУЖНО, ЭТО И ТАК ОЗНАЧАЕТ, ЧТО НАЧАЛО ГОДА - СМЕНА ГОДА ПРИ ПОСТРОЕНИИ ГРАФИКА НА БУДУЩИЕ ГОДА
   IF NVL(IS_VIRTUAL_,0) = 0 THEN
       IF P_CLAIM_PAY_OUT_ IS NOT NULL THEN
         -- 27.11.2024    Тайканов Е.Р.     Перенес получение значений переменных в запрос выше. 
         -- ВЧИСЛЯЕМ КАКОЙ ТИП У ЗАЯВЛЕНИЯ
         /*
         SELECT C.P_G_CLAIM_PAY_OUT_KND,
                C.SUMREMAIN
           INTO P_G_CLAIM_PAY_OUT_KND_,
                V_SUMREMAIN_FROM_CLAIM_
           FROM P_CLAIM_PAY_OUT C --(!) FROM P_CLAIM_PAY_OUT$$O C
          WHERE C.P_CLAIM_PAY_OUT = P_CLAIM_PAY_OUT_;
          */

         -- ПЕРЕБИВАЕМ ID-ПЕРЕДАННОГО ЗАЯВЛЕНИЯ НА ID ИСХОДНОГО ЗАЯВЛЕНИЯ
         /*
         IF P_G_CLAIM_PAY_OUT_KND_ != 1 THEN
            SELECT C.P_CLAIM_PAY_OUT_INITIAL
              INTO V_P_CLAIM_PAY_OUT_
              FROM P_CLAIM_PAY_OUT C --(!) FROM P_CLAIM_PAY_OUT$$O C
             WHERE C.P_CLAIM_PAY_OUT = P_CLAIM_PAY_OUT_;
         ELSE
            V_P_CLAIM_PAY_OUT_ := P_CLAIM_PAY_OUT_;
         END IF;
         */
         NULL;
       ELSE
         V_P_CLAIM_PAY_OUT_ := 0;
       END IF;

       BLOCK_ := '05';
       -- Вычисляем количество заявлений (кроме наследников, погребение, выезд за границу, по решению суда) с типом заявления = 1 за предыдущие года.
       -- Есть ли хоть одно другое(не совпадает ID) заявление с неошибочным статусом не зависимо открыто или закрыто, но год даты регистрации которого строго меньше года входящего параметра
       SELECT COUNT(1)
         INTO V_COUNT_CLAIM_BEFORE_
         FROM P_CLAIM_PAY_OUT C,
              P_G_PAY_OUT_SUB_TYPE T
        WHERE C.P_G_CLAIM_PAY_OUT_KND = 1
          AND C.P_CONTRACT = P_CONTRACT_
          AND C.P_G_PAY_OUT_SUB_TYPE = T.P_G_PAY_OUT_SUB_TYPE
          AND T.P_G_PAY_OUT_TYPE NOT IN (3,4,5,50)
          AND C.P_CLAIM_PAY_OUT <> V_P_CLAIM_PAY_OUT_
          -- 18.05.2018: ПО ЗАЯВКЕ №3 2018, В РАМКАХ ДОРАБОТКИ ПЕРЕДАЧИ ВЫПЛАТ ГК, ДЛЯ ЗАЯВЛЕНИЙ ПОЛУЧЕННЫХ ИЗ ГК НАДО СТРОИТЬ ГРАФИК ОТ ДАТЫ ПРИЁМА ЗАЯВЛЕНИЯ, А НЕ ОТ ДАТЫ РЕГИСТРАЦИИ
          --AND TO_NUMBER(TO_CHAR(C.DATE_REGISTR,'YYYY')) < TO_NUMBER(TO_CHAR(DATE_,'YYYY'))
          --AND TO_NUMBER(TO_CHAR(DECODE(C.P_G_REGISTRATION_TYPE,4,C.DATE_RECEPTION,C.DATE_REGISTR),'YYYY')) < TO_NUMBER(TO_CHAR(DATE_,'YYYY'))-- 18.05.2018: ПО ЗАЯВКЕ №4 2018, В РАМКАХ ДОРАБОТКИ ПЕРЕДАЧИ ВЫПЛАТ ГК, ДЛЯ ЗАЯВЛЕНИЙ ПОЛУЧЕННЫХ ИЗ ГК НАДО СТРОИТЬ ГРАФИК ОТ ДАТЫ ПРИЁМА ЗАЯВЛЕНИЯ, А НЕ ОТ ДАТЫ РЕГИСТРАЦИИ
          AND TO_NUMBER(TO_CHAR(
              DECODE(C.P_G_REGISTRATION_TYPE,4,
              -- если в заявлениях ГК дата приема заявления сидит в будущих годах (такое может быть т.к. в качестве даты приема указывается дата достижения вкладчиком пенсионного возраста)
              -- то в дате приема заявления заменяем будущий год на текщуий год
              CASE WHEN TO_CHAR(C.DATE_RECEPTION,'YYYY') > TO_CHAR(SYSDATE,'YYYY') THEN TO_DATE(TO_CHAR(C.DATE_RECEPTION,'dd.mm.')||TO_CHAR(SYSDATE,'YYYY'),'dd.mm.yyyy')
              ---------------
              ELSE C.DATE_RECEPTION END,
              C.DATE_REGISTR),'YYYY'))
              < TO_NUMBER(TO_CHAR(DATE_,'YYYY'))
          -------------------------------------------------
          AND C.P_G_CLAIM_STATUS = 8;

       BLOCK_ := '10';
       -- Вычисляем количество заявлений (кроме наследников, погребение, выезд за границу, по решению суда) с типом заявления = 1 в текущем году.
       -- То есть существует ли хоть одно другое(не совпадает ID) заявление с неошибочным статусом не зависимо открыто или закрыто, но год даты регистрации которого совпадает с годом входящего параметра
       SELECT COUNT(1)
         INTO V_COUNT_YEAR_CLAIM_
         FROM P_CLAIM_PAY_OUT C,
              P_G_PAY_OUT_SUB_TYPE T
        WHERE C.P_G_CLAIM_PAY_OUT_KND = 1
          AND C.P_CONTRACT = P_CONTRACT_
          AND C.P_G_PAY_OUT_SUB_TYPE = T.P_G_PAY_OUT_SUB_TYPE
          AND T.P_G_PAY_OUT_TYPE NOT IN (3,4,5,50)
          AND C.P_CLAIM_PAY_OUT <> V_P_CLAIM_PAY_OUT_
          -- 18.05.2018: ПО ЗАЯВКЕ №4 2018, В РАМКАХ ДОРАБОТКИ ПЕРЕДАЧИ ВЫПЛАТ ГК, ДЛЯ ЗАЯВЛЕНИЙ ПОЛУЧЕННЫХ ИЗ ГК НАДО СТРОИТЬ ГРАФИК ОТ ДАТЫ ПРИЁМА ЗАЯВЛЕНИЯ, А НЕ ОТ ДАТЫ РЕГИСТРАЦИИ
          --AND TO_CHAR(DECODE(C.P_G_REGISTRATION_TYPE,4,C.DATE_RECEPTION,C.DATE_REGISTR),'YYYY') = TO_CHAR(DATE_,'YYYY')-- 18.05.2018: ПО ЗАЯВКЕ №4 2018, В РАМКАХ ДОРАБОТКИ ПЕРЕДАЧИ ВЫПЛАТ ГК, ДЛЯ ЗАЯВЛЕНИЙ ПОЛУЧЕННЫХ ИЗ ГК НАДО СТРОИТЬ ГРАФИК ОТ ДАТЫ ПРИЁМА ЗАЯВЛЕНИЯ, А НЕ ОТ ДАТЫ РЕГИСТРАЦИИ
          AND TO_CHAR(
              DECODE(C.P_G_REGISTRATION_TYPE,4,
              -- если в заявлениях ГК дата приема заявления сидит в будущих годах (такое может быть т.к. в качестве даты приема указывается дата достижения вкладчиком пенсионного возраста)
              -- то в дате приема заявления заменяем будущий год на текщуий год
              CASE WHEN TO_CHAR(C.DATE_RECEPTION,'YYYY') > TO_CHAR(SYSDATE,'YYYY') THEN TO_DATE(TO_CHAR(C.DATE_RECEPTION,'dd.mm.')||TO_CHAR(SYSDATE,'YYYY'),'dd.mm.yyyy')
              ---------------
              ELSE C.DATE_RECEPTION END,
              C.DATE_REGISTR),'YYYY')
              = TO_CHAR(DATE_,'YYYY')
          -------------------------------------------------
          AND C.P_G_CLAIM_STATUS = 8;


       BLOCK_ := '15';
       -- Вычисляем количество выплат по заявлениям (кроме наследников, погребение, выезд за границу, по решению суда) с типом заявления = 1 в текущем году по другим заявлениям (то есть исключая ID данного заявления).
       -- Можно вычислить из P_PAYMENT_INFO год из даты периода совпадает с годом входящего параметра с статусом 1
       SELECT COUNT(1)
         INTO V_COUNT_YEAR_PAYMENTS_
         FROM P_CLAIM_PAY_OUT C,
              P_G_PAY_OUT_SUB_TYPE T,
              P_PAYMENT_INFO I,
              P_CLAIM_PAY_OUT C2
        WHERE C.P_G_CLAIM_PAY_OUT_KND = 1
          AND C.P_CONTRACT = P_CONTRACT_
          AND C.P_G_PAY_OUT_SUB_TYPE = T.P_G_PAY_OUT_SUB_TYPE
          AND T.P_G_PAY_OUT_TYPE NOT IN (3,4,5,50)
          AND C.P_CLAIM_PAY_OUT <> V_P_CLAIM_PAY_OUT_
          AND C.P_G_CLAIM_STATUS = 8
          -- ЭТО НА ТОТ СЛУЧАЙ, ЕСЛИ В P_PAYMENT_INFO ССЫЛАЕТСЯ НЕ НА ЕАЧАЛЬНОЕ ЗАЯВЛЕНИЕ, А НА ИЗМЕНЕНИЕ БАНКОСКИХ РЕКВИЗИТОВ
          -- В ЭТОМ СЛУЧАЕ ЭТО ВСЕ РАВНО ЭТО ВЫПЛАТЫ ТОГО ЖЕ САМОГО НАЧАЛЬНОГО ЗАЯВЛЕНИЯ НА ВЫПЛАТУ
          AND I.P_CLAIM_PAY_OUT = C2.P_CLAIM_PAY_OUT
          -- EKOPYLOV 18.01.2021 ПО ВКЛАДЧИКУ 561202301232, СОЗДАЛАСЬ ЗАПИСЬ В ВЫПЛАТЕ НО ОНА НЕ ПРОШЛА, ОТВАЛИЛАСЬ С ОШИБКОЙ -1. ТАКИЕ ЗАПИСИ НЕ НАДО УЧИТАВАТЬ ТУТ.
          AND I.STATUS >= 0
          AND C2.P_CLAIM_PAY_OUT_INITIAL = C.P_CLAIM_PAY_OUT
          --------------------------------
          AND TO_CHAR(I.DATE_1,'YYYY') = TO_CHAR(DATE_,'YYYY')
          AND I.DATE_1 <> I.DATE_2; -- ЧТОБЫ ИСКЛЮЧИТЬ ВЫСПЛАТЫ С КЗ, ОНИ НЕ ДОЛЖНЫ УЧИТЫВАТЬСЯ КАК ВЫПЛАТЫ

       BLOCK_ := '20';
       -- Вычисляем количество выплат заявлениям (кроме наследников, погребение, выезд за границу, по решению суда) с типом заявления = 1 в текущем году независимо от заявления.
       -- То есть вычисляется точно так же как переменная V_COUNT_YEAR_PAYMENTS_ но только надо убрать условие исключая ID данного заявления
       -- и дату первой выплаты в текущем году
       SELECT COUNT(1),
              MIN(W.WORK_DATE),
              MIN(I.P_PAYMENT_INFO)
         INTO V_COUNT_YEAR_ALL_PAYMENTS_,
              V_DATE_FIRST_PAY_YEAR_,
              V_P_PAYMENT_INFO_
         FROM P_CLAIM_PAY_OUT C,
              P_G_PAY_OUT_SUB_TYPE T,
              P_PAYMENT_INFO I,
              P_CLAIM_PAY_OUT C2,
              WORKING_DATE W
        WHERE C.P_G_CLAIM_PAY_OUT_KND = 1
          AND C.P_CONTRACT = P_CONTRACT_
          AND C.P_G_PAY_OUT_SUB_TYPE = T.P_G_PAY_OUT_SUB_TYPE
          AND T.P_G_PAY_OUT_TYPE NOT IN (3,4,5,50)
          AND C.P_G_CLAIM_STATUS = 8
          -- ЭТО НА ТОТ СЛУЧАЙ, ЕСЛИ В P_PAYMENT_INFO ССЫЛАЕТСЯ НЕ НА ЕАЧАЛЬНОЕ ЗАЯВЛЕНИЕ, А НА ИЗМЕНЕНИЕ БАНКОСКИХ РЕКВИЗИТОВ
          -- В ЭТОМ СЛУЧАЕ ЭТО ВСЕ РАВНО ЭТО ВЫПЛАТЫ ТОГО ЖЕ САМОГО НАЧАЛЬНОГО ЗАЯВЛЕНИЯ НА ВЫПЛАТУ
          AND I.P_CLAIM_PAY_OUT = C2.P_CLAIM_PAY_OUT
          AND C2.P_CLAIM_PAY_OUT_INITIAL = C.P_CLAIM_PAY_OUT
          --------------------------------
          AND TO_CHAR(I.DATE_1,'YYYY') = TO_CHAR(DATE_,'YYYY')
          AND W.WORKING_DATE = I.WORKING_DATE
          AND I.STATUS = 1
          AND I.DATE_1 <> I.DATE_2; -- ЧТОБЫ ИСКЛЮЧИТЬ ВЫСПЛАТЫ С КЗ, ОНИ НЕ ДОЛЖНЫ УЧИТЫВАТЬСЯ КАК ВЫПЛАТЫ

       BLOCK_ := '21';
       -- Вычисляем количество выплат по данному заявлению в текущем году.
       -- То есть вычисляется точно так же как переменная V_COUNT_YEAR_PAYMENTS_ но только надо убрать условие исключая ID данного заявления
       -- и дату первой выплаты в текущем году
       SELECT COUNT(1)
         INTO V_COUNT_PAY_YEAR_THIS_CLAIM
         FROM P_CLAIM_PAY_OUT C,
              P_PAYMENT_INFO I
        WHERE C.P_CLAIM_PAY_OUT_INITIAL = v_p_claim_pay_out_initial
          AND I.P_CLAIM_PAY_OUT = C.P_CLAIM_PAY_OUT
          AND TO_CHAR(I.DATE_1,'YYYY') = TO_CHAR(DATE_,'YYYY')
          AND I.STATUS = 1
          AND I.DATE_1 <> I.DATE_2; -- ЧТОБЫ ИСКЛЮЧИТЬ ВЫСПЛАТЫ С КЗ, ОНИ НЕ ДОЛЖНЫ УЧИТЫВАТЬСЯ КАК ВЫПЛАТЫ

       BLOCK_ := '25';
       -- Вычисляем количество заявлений (кроме наследников, погребение, выезд за границу, по решению суда) с типом заявления = 1 в текущем году включая это заявление тоже.
       -- Определяется как переменная V_COUNT_YEAR_CLAIM_, единственно надо убать условия что не должно совпадать ID заявления
       SELECT COUNT(1)
         INTO V_COUNT_YEAR_CLAIM_WITH_
         FROM P_CLAIM_PAY_OUT C,
              P_G_PAY_OUT_SUB_TYPE T
        WHERE C.P_G_CLAIM_PAY_OUT_KND = 1
          AND C.P_CONTRACT = P_CONTRACT_
          AND C.P_G_PAY_OUT_SUB_TYPE = T.P_G_PAY_OUT_SUB_TYPE
          AND T.P_G_PAY_OUT_TYPE NOT IN (3,4,5,50)
          -- 18.05.2018: ПО ЗАЯВКЕ №4 2018, В РАМКАХ ДОРАБОТКИ ПЕРЕДАЧИ ВЫПЛАТ ГК, ДЛЯ ЗАЯВЛЕНИЙ ПОЛУЧЕННЫХ ИЗ ГК НАДО СТРОИТЬ ГРАФИК ОТ ДАТЫ ПРИЁМА ЗАЯВЛЕНИЯ, А НЕ ОТ ДАТЫ РЕГИСТРАЦИИ
          --AND TO_CHAR(DECODE(C.P_G_REGISTRATION_TYPE,4,C.DATE_RECEPTION,C.DATE_REGISTR),'YYYY') = TO_CHAR(DATE_,'YYYY')-- 18.05.2018: ПО ЗАЯВКЕ №4 2018, В РАМКАХ ДОРАБОТКИ ПЕРЕДАЧИ ВЫПЛАТ ГК, ДЛЯ ЗАЯВЛЕНИЙ ПОЛУЧЕННЫХ ИЗ ГК НАДО СТРОИТЬ ГРАФИК ОТ ДАТЫ ПРИЁМА ЗАЯВЛЕНИЯ, А НЕ ОТ ДАТЫ РЕГИСТРАЦИИ
          AND TO_CHAR(
              DECODE(C.P_G_REGISTRATION_TYPE,4,
              -- если в заявлениях ГК дата приема заявления сидит в будущих годах (такое может быть т.к. в качестве даты приема указывается дата достижения вкладчиком пенсионного возраста)
              -- то в дате приема заявления заменяем будущий год на текщуий год
              CASE WHEN TO_CHAR(C.DATE_RECEPTION,'YYYY') > TO_CHAR(SYSDATE,'YYYY') THEN TO_DATE(TO_CHAR(C.DATE_RECEPTION,'dd.mm.')||TO_CHAR(SYSDATE,'YYYY'),'dd.mm.yyyy')
              ---------------
              ELSE C.DATE_RECEPTION END,
              C.DATE_REGISTR),'YYYY')
          = TO_CHAR(DATE_,'YYYY')
          ------------------
          --AND C.P_G_CLAIM_STATUS = 8
          AND C.P_G_CLAIM_STATUS NOT IN (-7,-3,-2); -- НЕ ОШИБОЧНЫЕ, Т.К ПРИ ПЕРВОЙ ВЫПЛАТЕ В ДУиОПА СТАТУС ЗАЯЛВЕНИЯ НЕ 8, А ЕЩЁ 5, НО ПРИ ЭТОМ НАДО ДАННОЕ ЗАЯВЛЕНИЕ ПОДСЧИТЫВАТЬ В ОБЩЕЕ КОЛ-ВО ЗАЯВЛЕНИЙ

       BLOCK_ := '26';
       -- Сарсенбаев Б.О. 25.09.2018: Доработка по заявке №5 о определении суммы выплаты на дату обращения для заявлений по новому законодательству
       -- Вычисляем операционную дату осуществления первой выплаты по данному заявлению за все время
       select min(i.working_date) into V_WORKING_DATE_FIRST_PAY -- вычислил ID операционной даты первой выплаты
       from p_payment_info i
       where exists (select 1 from p_claim_pay_out pp where pp.P_CLAIM_PAY_OUT_INITIAL = v_p_claim_pay_out_initial and pp.P_CLAIM_PAY_OUT = i.p_claim_pay_out)
             and i.status = 1;
       IF V_WORKING_DATE_FIRST_PAY IS NOT NULL THEN
         select w.work_date into V_WORK_DATE_FIRST_PAY from working_date w where w.working_date = V_WORKING_DATE_FIRST_PAY; -- вычислил операционную дату первой выплаты
       END IF;

       -- Условия основной логики вычисления остатка на начало года и признака ВИПа
       IF (V_COUNT_YEAR_CLAIM_WITH_ > 0 OR P_CLAIM_PAY_OUT_ IS NULL) AND NVL(IS_VIRTUAL_,0) != 1 THEN
          --------------------------------------------------------------
          -- заявление подали в текущем году                          --
          --------------------------------------------------------------
          -- Сарсенбаев Б.О. 25.09.2018: Доработка по заявке №5 о определении суммы выплаты на дату обращения для заявлений по новому законодательству
          -- Новый блок. Вычисляем признак V_IS_ON_OPER_CLAIM_DATE  что пенсионные накопления для вычисляения суммы выплаты
          -- должны браться на операционную а не календарную дату обращения вкладчика. Это требуется для заявлений на выплату по законодательству, действующему с 01.01.2018г.
          -- (то есть у которых IS_HAVE_RIGHT_REG_OLD_LAW_ = 0) для которых действует одно из следующих условий: это заявление подано через ГК (т.е. P_G_REGISTRATION_TYPE_ = 4)
          -- или заявление подали в ЕНПФ после установки этой доработки (старые заявления обрабатываются по старому алгоритму - 5 случаев(точнее из этих 5-ти случае там всегда срабатывает на календарную дату подачи заявления))
          BLOCK_ := '27';
          V_IS_ON_OPER_CLAIM_DATE := 0;
          -- 03.05.2020: МАМЕТОВ С.А. ПО ЗАДАЧЕ №508960 ДЛЯ ДО ВЫПЛАТ ОСТАТОК ДОЛЖЕН СЧИТАТЬСЯ НА ТЕКУЩУЙ МОМЕНТ А НЕ НА МОМЕНТ ПОДАЧИ ЗАЯВЛЕНИЯ
          IF IS_HAVE_RIGHT_REG_OLD_LAW_ = 0 AND IS_PAY_EXTRA_ = 0 THEN
            IF P_G_REGISTRATION_TYPE_ = 4 THEN
              -- если заявление подали через ГК, то ее обрабатываем по новому (т.е. по операционной дате обращения)
              V_IS_ON_OPER_CLAIM_DATE := 1; -- поставил признак что надо вычилять на операционную дату обращения
              ------------
            ELSE
              -- если заявление подали в ЕНПФ, определяю это заявление подали до установки доработки или уже после установки доработки.
              -- Определяем по следующему принципу. Если первая выплата по данному заявлению была осуществлена до определенной
              -- операционной даты, то это старое заявление. Иначе новое заявление
              IF P_CLAIM_PAY_OUT_ IS NULL THEN
                -- если заявления еще нет то есть его только создают, то это точно новое заявление и ее обрабатываем по новому (т.е. по операционной дате обращения)
                V_IS_ON_OPER_CLAIM_DATE := 1;
                ------------
              ELSE
                -- если заявление существует
                IF V_WORK_DATE_FIRST_PAY IS NULL THEN
                  -- если еще не было ни одной выплаты, то ее обрабатываем по новому (т.е. по операционной дате обращения)
                  V_IS_ON_OPER_CLAIM_DATE := 1;
                ELSE
                  -- если операционная дата первой выплаты была осуществлена после установки доработки, то ее обрабатываем по новому (т.е. по операционной дате обращения)
                  IF V_WORK_DATE_FIRST_PAY > TO_DATE('10.10.2018','dd.mm.yyyy') THEN --TO_DATE('01.10.2018','dd.mm.yyyy') THEN
                    V_IS_ON_OPER_CLAIM_DATE := 1;
                  ELSE
                    V_IS_ON_OPER_CLAIM_DATE := 0;
                  END IF;
                END IF;
                ---------------
              END IF;
            END IF;
          END IF;
          -----------------------
          BLOCK_ := '28';
          -- 25.09.2018 Сарсенбаев Б.О.: Заявка №5 о определении суммы выплаты на дату обращения для заявлений по новому законодательству
          -- Вычисляю дату обращения вкладчика и помещаю ее в переменную DATE_CONTACT_.
          -- Датой обращения вкладчика являются:
          -- 1)	Если это заявление на выплату создано на основе запроса ГК (то есть в поле «Способ подачи заявления» указано значение «Через ГК»).
          --    a.	Если вкладчик, по которому создано это заявление, достиг пенсионного возраста, то датой обращения является дата, указанная в сообщении PENS  в поле applyDateGK (Дата регистрации заявления на выплату в АИС Министерства).
          --    b.	Если вкладчик не достиг пенсионного возраста, то датой обращения является дата достижения этим вкладчиком пенсионного возраста.
          --    Именно по такому принципу сейчас Айдын при вставки заявлении на выплату ГК автоматически заполняет поле «Дата приема заявления».
          --    То есть мне достаточно брать значение из этого поля «Дата приема заявления»
          -- 2)	Если это заявление на выплату зарегистрировано в фронт-офисе ЕНПФ(то есть в поле «Способ подачи заявления» указано значение отличное от «Через ГК»).
          --    Датой обращения вкладчика является дата, когда он обратился в ЕНПФ. То есть в этом случае, дата обращения также берется из заявления на выплату из поля «Дата приема заявления».
          -- Получается для всех указанных случаев дата обращения сидит в заявлении на выплату в поле «Дата приема заявления»
          IF V_IS_ON_OPER_CLAIM_DATE = 1 THEN -- выше в блоке 27 в эту переменную V_IS_ON_OPER_CLAIM_DATE поместил признак что надо вычислять на дату обращения
            DATE_CONTACT_ := TRUNC(DATE_RECEPTION_); -- специально объявил отдельную переменную DATE_CONTACT_. Вдруг в будущем измениться и дата обращения не будет сидеть
                                             -- в дате приема заявления, а ее надо будет отдельно вычислять
          END IF;


          IF V_IS_ON_OPER_CLAIM_DATE = 1 THEN -- выше в блоке 27 в эту переменную V_IS_ON_OPER_CLAIM_DATE поместил признак что надо вычислять на дату обращения
              BLOCK_ := '29';
              -- 25.09.2018 Сарсенбаев Б.О.: Заявка №5 о определении суммы выплаты на дату обращения для заявлений по новому законодательству
              -- Определяю остаток ПН и значение минимальной пенсии на дату обращения вкладчика.
              -- Определение происходит по следующему алгоритму:
              -- a)	если по данному заявлению еще не было произведено ни одной выплаты, то:
              --   a.1) если текущая операционная дата строго меньше чем дата обращения - то в переменную V_SUMM_ пихать остаток на начало текущего операционного дня (понятно что при повторном вызове пересчета графика пока еще операционная дата не догнала дату ГК или еще не была осуществлена 	первая выплата по данному заявлению - эта сумма будет каждый раз меняться). Соответственно переменная MIN_PENS_ON_DATE_CONCTACT_ должна содержать значение минимальной пенсии также по состоянию на текущую операционную дату;
              --   a.2) если текущая операционная больше или равна чем дата обращения - то в переменную V_SUMM_ пихать остаток на дату обращения. Соответственно переменная MIN_PENS_ON_DATE_CONCTACT_ должна содержать значение минимальной пенсии также по состоянию на дату обращения;
              -- b)	если по данному заявлению была произведена хоть одна выплата, то:
              --   b.1) если операционная дата осуществления этой первой выплаты строго меньше чем дата обращения - то в переменную V_SUMM_ пихать остаток на дату первой выплаты (точнее на начало этого дня). Соответственно переменная MIN_PENS_ON_DATE_CONCTACT_ должна содержать значение минимальной пенсии также по состоянию на дату первой выплаты
              --   b.2) если операционная дата осуществления этой первой выплаты больше или равна дате обращения - то в переменную  V_SUMM_ пихать остаток на дату обращения (точнее на начало этого дня). Соответственно переменная MIN_PENS_ON_DATE_CONCTACT_ должна содержать значение минимальной пенсии также по состоянию на дату обращения
              DECLARE
                   v_my_date DATE; -- дата на которую надо брать остаток пенсионных накоплений и размер минимальной пенсии
                   v_my_working_date number; -- это id-ка этого дня
              BEGIN
                IF V_WORK_DATE_FIRST_PAY IS NULL THEN
                  -- если не было еще ни одной осуществленной выплаты по данному заявлению
                  IF v_WORK_DATE < DATE_CONTACT_ THEN
                    -- если текущая операционная дата строго меньше чем дата обращения - то остаток ПН и размер минимальной пенсии беру на начало текущей операционной даты
                    v_my_date := v_WORK_DATE;
                  ELSE
                    -- если текущая операционная больше или равна чем дата обращения - то остаток ПН и размер минимальной пенсии беру на дату обращения (точнее на начало дня)
                    -- остаток ПН на начало даты обращения равен произведению количества у.е. на конец предыдущего дня умножить на курс у.е. даты обращения
                    v_my_date := DATE_CONTACT_;
                  END IF;
                  
                  --IF p_g_Pay_Out_Sub_Type_ IN (600, 601, 602, 603) THEN
                  -- 27.11.2024    Тайканов Е.Р.     Если выплата по графику, то берем остатки во всех УИП
                  FOR REC_PRTF IN (SELECT O.P_G_PORTFOLIO
                                   FROM   P_CONTRACT_PORTFOLIO O
                                   WHERE  O.P_CONTRACT = P_CONTRACT_)
                  LOOP
                    V_SUMM_ := nvl(V_SUMM_,0) + round(pension_pack.GET_P_CONTRACT_PRTF_BALANCE(P_CONTRACT_, REC_PRTF.P_G_PORTFOLIO),2);
                  END LOOP;    
                  --ELSE
                    -- 30.06.2023        Тайканов Е.Р.      Задача КП Битрикс № 933477. По задаче если на момент расчета выплаты остаток на счете менее 12 МинПенсии, то выплачиваем весь остаток.
                    --                                      Раньше брали остаток на дату заявления.
                    --V_SUMM_ := round(pension_pack.get_contract_balance_amount(P_CONTRACT_,1)*
                    --                      NVL(K_CURRENCY_COURSE_PACK.GET_PENSION_COURSE_REC(1, v_working_date),0), 2)/* - NVL(SUM_TAX_DEFERRAL_, 0)*/;
                  --END IF;


                ELSE
                  -- если была хоть одна осуществленная выплата по данному заявлению
                  IF V_WORK_DATE_FIRST_PAY < DATE_CONTACT_ THEN
                    -- если операционная дата осуществления первой выплаты строго меньше чем дата обращения - то остаток ПН и размер минимальной пенсии беру на дату первой выплаты
                    v_my_date := V_WORK_DATE_FIRST_PAY;
                  ELSE
                    -- если операционная дата осуществления этой первой выплаты больше или равно дате обращения - то остаток ПН и размер минимальной пенсии беру на дату обращения (точнее на начало дня)
                    v_my_date := DATE_CONTACT_;
                  END IF;
                  -- 30.06.2023     Тайканов Е.Р.       Оперделение значения SUM_REMAIN_ON_DATE_CONCTACT_ перенес во внутрь условия, так как для первой выплаты алгритм поменялся.
                  -- 07.11.2018 Сарсенбаев Б.О.: Согласно уточняющей Заявке №19507 по сопровождению, остаток ПН на начало дня равен произведению количества у.е. на конец предыдущего дня умножить на курс у.е. того же предыдущего дня
                  -- 04-01-2021: МАМЕТОВ СЕРИК АЛИМАМЕТОВИЧ: ПОСЛЕ РАЗЪЯСНЕНИИ КГД КАСАТЕЛЬНО УЧЕТА ОТЛОЖЕННОГО ИПН ИЗМЕНИЛИСЬ РАСЧЕТЫ, ИЗМЕНИЛСЯ ПОДХОД К УЧЕТУ ОТЛОЖЕННОГО ИПН
                  -- УБРАЛ ЭТОТ ПУНКТ  - NVL(SUM_TAX_DEFERRAL_, 0) ИЗ ФОРМУЛ
                  SELECT w.working_date INTO v_my_working_date FROM WORKING_DATE w WHERE w.work_date = v_my_date-1;
                  V_SUMM_ := ROUND(main.pension_pack.GET_P_CONTR_PRTF_SUMM_CU_DATE(P_CONTRACT_,1,v_my_date-1) *
                                   NVL(K_CURRENCY_COURSE_PACK.GET_PENSION_COURSE_REC(1, v_my_working_date),0),2)/* - NVL(SUM_TAX_DEFERRAL_, 0)*/;
                END IF;

                -- размер минимальной менсии также беру по состоянию на данный день
                SELECT G.VALUE
                INTO MIN_PENS_ON_DATE_CONCTACT_
                FROM G_MINIMAL_DESIGN_INDEX G
                WHERE G.G_PARAMETER = 2 AND
                   G.K_DAY = (SELECT MAX(G2.K_DAY)
                              FROM G_MINIMAL_DESIGN_INDEX G2
                              WHERE G2.G_PARAMETER = 2 AND
                                    G2.K_DAY <= v_my_date
                              );
                ---------------------------------------------------------------
              END;
          ELSE
            --Если обычное заявление (то есть не надо определять сумму ПН на дату обращения вкладчика) - то рассматриваем наши 5 случаев из алгоритма
            -- 1.1) рассматриваем 1-ый случай из требований
            IF V_COUNT_CLAIM_BEFORE_ = 0 AND V_COUNT_YEAR_CLAIM_ = 0 THEN
              BLOCK_ := '40';
              IF P_CLAIM_PAY_OUT_ IS NULL THEN
                 -- заявление регистрируют во фронт-офисе, остаток брать на текущую опер дату
                 BLOCK_ := '45';
                 -- 04-01-2021: МАМЕТОВ СЕРИК АЛИМАМЕТОВИЧ: ПОСЛЕ РАЗЪЯСНЕНИИ КГД КАСАТЕЛЬНО УЧЕТА ОТЛОЖЕННОГО ИПН ИЗМЕНИЛИСЬ РАСЧЕТЫ, ИЗМЕНИЛСЯ ПОДХОД К УЧЕТУ ОТЛОЖЕННОГО ИПН
                 -- УБРАЛ ЭТОТ ПУНКТ  - NVL(SUM_TAX_DEFERRAL_, 0) ИЗ ФОРМУЛЫ
                 V_SUMM_ := PENSION_PACK.GET_CONTRACT_SUMM_ON_DATE(P_CONTRACT_, TRUNC(SYSDATE)) +
                            P_GET_UE(P_CONTRACT_,TRUNC(SYSDATE))/* - NVL(SUM_TAX_DEFERRAL_, 0)*/;
              ELSE
                 -- пересчет графика, выплаты осуществляются в ДУиОПА, брать из самого заявления
                 BLOCK_ := '50';
                 V_SUMM_ := V_SUMREMAIN_FROM_CLAIM_;
              END IF;

            -- 1.2) рассматриваем 2-ой случай
            ELSIF V_COUNT_CLAIM_BEFORE_ > 0 AND V_COUNT_YEAR_CLAIM_=0 AND V_COUNT_YEAR_PAYMENTS_=0 THEN
              BLOCK_ := '55';
              IF P_CLAIM_PAY_OUT_ IS NULL THEN
                 -- заявление регистрируют во фронт-офисе, остаток брать на текущую опер дату
                 BLOCK_ := '60';
                 -- 04-01-2021: МАМЕТОВ СЕРИК АЛИМАМЕТОВИЧ: ПОСЛЕ РАЗЪЯСНЕНИИ КГД КАСАТЕЛЬНО УЧЕТА ОТЛОЖЕННОГО ИПН ИЗМЕНИЛИСЬ РАСЧЕТЫ, ИЗМЕНИЛСЯ ПОДХОД К УЧЕТУ ОТЛОЖЕННОГО ИПН
                 -- УБРАЛ ЭТОТ ПУНКТ  - NVL(SUM_TAX_DEFERRAL_, 0) ИЗ ФОРМУЛЫ
                 V_SUMM_ := PENSION_PACK.GET_CONTRACT_SUMM_ON_DATE(P_CONTRACT_, TRUNC(SYSDATE)) +
                            P_GET_UE(P_CONTRACT_,TRUNC(SYSDATE))/* - NVL(SUM_TAX_DEFERRAL_, 0)*/;
              ELSE
                 -- пересчет графика, выплаты осуществляются в ДУиОПА, брать из самого заявления
                 BLOCK_ := '65';
                 V_SUMM_ := V_SUMREMAIN_FROM_CLAIM_;
              END IF;

            -- 1.3) рассматриваем 3-ий случай
            ELSIF V_COUNT_CLAIM_BEFORE_ > 0 AND V_COUNT_YEAR_CLAIM_=0 AND V_COUNT_YEAR_PAYMENTS_>0 THEN
              -- остаток брать на дату первой выплаты в текущем году независимо от заявления
              BLOCK_ := '70';
              -- более универсальный вариант выхода на операцию выплаты через p_lt_opr_payment (более универсальный так как сработает и для одноразовых выплат а не только по графику)
              select min(lt.p_opr) INTO V_P_OPR2_ from main.p_lt_opr_payment lt where lt.p_payment_info = v_p_payment_info_; -- определили id операции начисления инвест дохода/убытка, связанной с этой выплатой (или если этой операции не было, то это сама выплата)
              -- определяем искомую сумму ПН непосредственно перед выплатой
              -- эта формула взята точно так же как в SLD файлах (т.е. из функции MAIN.P_GET_CONTRACT_SUMM_BEFORE_PAY)
              BLOCK_ := '105';
              -- 04-01-2021: МАМЕТОВ СЕРИК АЛИМАМЕТОВИЧ: ПОСЛЕ РАЗЪЯСНЕНИИ КГД КАСАТЕЛЬНО УЧЕТА ОТЛОЖЕННОГО ИПН ИЗМЕНИЛИСЬ РАСЧЕТЫ, ИЗМЕНИЛСЯ ПОДХОД К УЧЕТУ ОТЛОЖЕННОГО ИПН
              -- УБРАЛ ЭТОТ ПУНКТ  - NVL(SUM_TAX_DEFERRAL_, 0) ИЗ ФОРМУЛЫ
              select ROUND((O.SUM_REMAIN_CU * main.K_CURRENCY_COURSE_PACK.GET_PENSION_COURSE_REC(k.p_g_portfolio, o.working_date) -
                           (O.SUM_REMAIN - O.SUMMA)) + (O.SUM_REMAIN - O.SUMMA)/*-o.summa*/,2)/* - NVL(SUM_TAX_DEFERRAL_, 0)*/
              INTO V_SUMM_
              from main.p_opr o, P_G_OPRKND K
              where o.p_opr = V_P_OPR2_
                   and o.P_G_OPRKND = K.P_G_OPRKND;

              --V_SUMM_ := PENSION_PACK.GET_CONTRACT_SUMM_ON_DATE(P_CONTRACT_, V_DATE_FIRST_PAY_YEAR_) + P_GET_UE(P_CONTRACT_,V_DATE_FIRST_PAY_YEAR_);

            -- 1.4) рассматриваем 4-ий случай
            ELSIF V_COUNT_YEAR_CLAIM_>0 AND V_COUNT_YEAR_PAYMENTS_=0 THEN
              BLOCK_ := '75';
              IF P_CLAIM_PAY_OUT_ IS NULL THEN
                 -- заявление регистрируют во фронт-офисе, остаток брать на текущую опер дату
                 BLOCK_ := '80';
                 -- 04-01-2021: МАМЕТОВ СЕРИК АЛИМАМЕТОВИЧ: ПОСЛЕ РАЗЪЯСНЕНИИ КГД КАСАТЕЛЬНО УЧЕТА ОТЛОЖЕННОГО ИПН ИЗМЕНИЛИСЬ РАСЧЕТЫ, ИЗМЕНИЛСЯ ПОДХОД К УЧЕТУ ОТЛОЖЕННОГО ИПН
                 -- УБРАЛ ЭТОТ ПУНКТ  - NVL(SUM_TAX_DEFERRAL_, 0) ИЗ ФОРМУЛЫ
                 V_SUMM_ := PENSION_PACK.GET_CONTRACT_SUMM_ON_DATE(P_CONTRACT_, TRUNC(SYSDATE)) +
                            P_GET_UE(P_CONTRACT_,TRUNC(SYSDATE))/* - NVL(SUM_TAX_DEFERRAL_, 0)*/;
              ELSE
                 -- пересчет графика, выплаты осуществляются в ДУиОПА, брать из самого заявления
                 BLOCK_ := '85';
                 V_SUMM_ := V_SUMREMAIN_FROM_CLAIM_;
              END IF;

            -- 1.5) рассматриваем 5-ий случай
            ELSIF V_COUNT_YEAR_CLAIM_>0 AND V_COUNT_YEAR_PAYMENTS_>0 THEN
              -- остаток брать на дату первой выплаты в текущем году независимо от заявления
              BLOCK_ := '90';

              -- более универсальный вариант выхода на операцию выплаты через p_lt_opr_payment (более универсальный так как сработает и для одноразовых выплат а не только по графику)
              select min(lt.p_opr) INTO V_P_OPR2_ from main.p_lt_opr_payment lt where lt.p_payment_info = v_p_payment_info_; -- определили id операции начисления инвест дохода/убытка, связанной с этой выплатой (или если этой операции не было, то это сама выплата)
              -- определяем искомую сумму ПН непосредственно перед выплатой
              -- эта формула взята точно так же как в SLD файлах (т.е. из функции MAIN.P_GET_CONTRACT_SUMM_BEFORE_PAY)
              BLOCK_ := '105';
              -- 04-01-2021: МАМЕТОВ СЕРИК АЛИМАМЕТОВИЧ: ПОСЛЕ РАЗЪЯСНЕНИИ КГД КАСАТЕЛЬНО УЧЕТА ОТЛОЖЕННОГО ИПН ИЗМЕНИЛИСЬ РАСЧЕТЫ, ИЗМЕНИЛСЯ ПОДХОД К УЧЕТУ ОТЛОЖЕННОГО ИПН
              -- УБРАЛ ЭТОТ ПУНКТ  - NVL(SUM_TAX_DEFERRAL_, 0) ИЗ ФОРМУЛЫ
              select ROUND((O.SUM_REMAIN_CU * main.K_CURRENCY_COURSE_PACK.GET_PENSION_COURSE_REC(k.p_g_portfolio, o.working_date) -
                           (O.SUM_REMAIN - O.SUMMA)) + (O.SUM_REMAIN - O.SUMMA)/*-o.summa*/,2)/* - NVL(SUM_TAX_DEFERRAL_, 0)*/
              INTO V_SUMM_
              from main.p_opr o, P_G_OPRKND K
              where o.p_opr = V_P_OPR2_
                   and o.P_G_OPRKND = K.P_G_OPRKND;

              --V_SUMM_ := PENSION_PACK.GET_CONTRACT_SUMM_ON_DATE(P_CONTRACT_, V_DATE_FIRST_PAY_YEAR_) + P_GET_UE(P_CONTRACT_,V_DATE_FIRST_PAY_YEAR_);
            END IF;
          END IF;

       ELSE
          ----------------------------------------------------------------------------------------------------
          -- график строится по существующему заявлению, которое было введено в прошлом году или ранее      --
          ----------------------------------------------------------------------------------------------------
          BLOCK_ := '95';
          IF V_COUNT_YEAR_ALL_PAYMENTS_ = 0 THEN
            -- В ДУиОПА осуществляется первая выплата в этом году по прошлогоднему заявлению то остаток брать на текущую опер дату;
            BLOCK_ := '100';
            -- 04-01-2021: МАМЕТОВ СЕРИК АЛИМАМЕТОВИЧ: ПОСЛЕ РАЗЪЯСНЕНИИ КГД КАСАТЕЛЬНО УЧЕТА ОТЛОЖЕННОГО ИПН ИЗМЕНИЛИСЬ РАСЧЕТЫ, ИЗМЕНИЛСЯ ПОДХОД К УЧЕТУ ОТЛОЖЕННОГО ИПН
            -- УБРАЛ ЭТОТ ПУНКТ  - NVL(SUM_TAX_DEFERRAL_, 0) ИЗ ФОРМУЛЫ
            V_SUMM_ := PENSION_PACK.GET_CONTRACT_SUMM_ON_DATE(P_CONTRACT_, TRUNC(SYSDATE)) +
                       P_GET_UE(P_CONTRACT_,TRUNC(SYSDATE))/* - NVL(SUM_TAX_DEFERRAL_, 0)*/;
          ELSE
            -- В ДУиОПА осуществляется очередная не первая выплата по прошлогоднему заявлению то остаток брать на момент первой выплаты (до самой операции первой выплаты, а не на начало дня) в текущем году;
            BLOCK_ := '105';

            -- вариант выхода на операцию выплаты через график
            /*SELECT P_OPR INTO V_P_OPR_ FROM P_GRF G WHERE P_GRF = v_p_grf_; -- определили id самой операции первой выплаты
            BLOCK_ := '115';
            SELECT num_transaction INTO v_num_transaction_ FROM P_OPR WHERE P_OPR = V_P_OPR_;
            BLOCK_ := '120';
            select min(r.p_opr),min(k.p_g_portfolio) INTO V_P_OPR2_,V_P_G_PORTFOLIO_ from main.p_opr r,P_G_OPRKND K where r.num_transaction = v_num_transaction_ and R.P_G_OPRKND = K.P_G_OPRKND; -- определили id операции начисления инвест дохода/убытка, связанной с этой выплатой (это как раз и будет первая операция внутри этой транзакции)
            -- определяем искомую сумму ПН непосредственно перед выплатой
            -- эта формула взята точно так же как в SLD файлах (т.е. из функции MAIN.P_GET_CONTRACT_SUMM_BEFORE_PAY)
            select ROUND((O.SUM_REMAIN_CU * main.K_CURRENCY_COURSE_PACK.GET_PENSION_COURSE_REC(V_P_G_PORTFOLIO_, o.working_date) - (O.SUM_REMAIN - O.SUMMA)) + (O.SUM_REMAIN - O.SUMMA)-o.summa,2)
            INTO V_SUMM_
            from main.p_opr o where o.p_opr = V_P_OPR2_;*/

            -- более универсальный вариант выхода на операцию выплаты через p_lt_opr_payment (более универсальный так как сработает и для одноразовых выплат а не только по графику)
            select min(lt.p_opr) INTO V_P_OPR2_ from main.p_lt_opr_payment lt where lt.p_payment_info = v_p_payment_info_; -- определили id операции начисления инвест дохода/убытка, связанной с этой выплатой (или если этой операции не было, то это сама выплата)
            -- определяем искомую сумму ПН непосредственно перед выплатой
            -- эта формула взята точно так же как в SLD файлах (т.е. из функции MAIN.P_GET_CONTRACT_SUMM_BEFORE_PAY)
            BLOCK_ := '105';
            -- 04-01-2021: МАМЕТОВ СЕРИК АЛИМАМЕТОВИЧ: ПОСЛЕ РАЗЪЯСНЕНИИ КГД КАСАТЕЛЬНО УЧЕТА ОТЛОЖЕННОГО ИПН ИЗМЕНИЛИСЬ РАСЧЕТЫ, ИЗМЕНИЛСЯ ПОДХОД К УЧЕТУ ОТЛОЖЕННОГО ИПН
            -- УБРАЛ ЭТОТ ПУНКТ  - NVL(SUM_TAX_DEFERRAL_, 0) ИЗ ФОРМУЛЫ
            select ROUND((O.SUM_REMAIN_CU * main.K_CURRENCY_COURSE_PACK.GET_PENSION_COURSE_REC(k.p_g_portfolio, o.working_date) -
                         (O.SUM_REMAIN - O.SUMMA)) + (O.SUM_REMAIN - O.SUMMA)/*-o.summa*/,2)/* - NVL(SUM_TAX_DEFERRAL_, 0)*/
            INTO V_SUMM_
            from main.p_opr o, P_G_OPRKND K
            where o.p_opr = V_P_OPR2_
                 and o.P_G_OPRKND = K.P_G_OPRKND;
            -------------
            --V_SUMM_ := PENSION_PACK.GET_CONTRACT_SUMM_ON_DATE(P_CONTRACT_, V_DATE_FIRST_PAY_YEAR_) + P_GET_UE(P_CONTRACT_,V_DATE_FIRST_PAY_YEAR_);
          END IF;
       END IF;

   -- ЕСЛИ ВХОДНОЙ АРГУМЕНТ IS_VIRTUAL_ = 1 ТО ОСТАТОК ВЫЧИСЛЯТЬ НЕ НУЖНО, БЕРЕМ ТАКОЙ КАК ОН ПРИШЕЛ ВО ВХОДНОМ ПАРАМЕТРЕ SUMM_REMAIN_
   ELSE
      V_SUMM_ := SUMM_REMAIN_;
   END IF; -- IS_VIRTUAL_


  ---------------------------------------------------------------------------------------------
  -- ПЕРВАЯ ВЕЛИЧИНА ИЗ АЛГОРИТМА (то есть 30-ти кратная минимальная пенсия)
  -- если минимальная пенсия не менялась посередине года - то вычисляется очень просто
  -- т.е. 30 умножить на минимальную пенсию
  -- если же минимальная пенсия менялась - то алгоритм сложней

  IF IS_HAVE_RIGHT_REG_OLD_LAW_ != 0 THEN -- Сарсенбаев Б.О. 25.09.2018: Первая величина из алгоритма играет роль только для зявлений по старому законодательству
    --1. определяем менялась ли минимальная пенсия посередине года
    SELECT A.WORK_DATE
      INTO CURRENT_WORKING_DATE_
      FROM V_CURRENT_WORKING_DATE A WHERE ROWNUM = 1;

    -- ОПРЕДЕЛЯМ ДАТУ ОТНОСИТЕЛЬНО КОТОРОЙ НАДО ИСКАТЬ БЛИЖАЙШИЙ ПОКАЗАТЕЛЬ МИНИМАЛЬНОЙ ПЕНСИИ
    IF TO_CHAR(DATE_,'YYYY') = TO_CHAR(CURRENT_WORKING_DATE_,'YYYY') THEN
       BASE_DATE_ := CURRENT_WORKING_DATE_;
    ELSE
       BASE_DATE_ := DATE_;
    END IF;

      SELECT G.VALUE,
             G.K_DAY,
             G.G_MINIMAL_DESIGN_INDEX
        INTO MIN_PENS_VALUE_,
             MIN_PENS_DATE_,
             MIN_PENS_ID_
        FROM G_MINIMAL_DESIGN_INDEX G
       WHERE G.G_PARAMETER = 2 AND
             G.K_DAY = (SELECT MAX(G2.K_DAY)
                          FROM G_MINIMAL_DESIGN_INDEX G2
                         WHERE G2.G_PARAMETER = 2 AND
                               G2.K_DAY <= BASE_DATE_
                         );

    -- НА СОВЕЩАНИИ МЫ ХОТЕЛИ, ЧТОБЫ ВСЕМ НЕ ВИПАМ ПРИ ЛЮБЫХ УСЛОВИЯХ СЧИТАЛОСЬ ОДИНАКОВО (Т.Е. ПО ГИБРИДНОЙ СУММЕ), НО ВИКА СКАЗАЛА, ЧТО
    -- У НИХ ЕСТЬ ОТВЕТ ЮРИСТОВ, ГДЕ РАЗЬЯСНЕНО, ЧТО ЕСЛИ У ЧЕЛОВЕКА НЕ БЫЛО ВЫПЛАТ ПО СТАРОМУ ПОКАЗАТЕЛЮ В ЭТОМ ГОДУ, ТО ЕМУ СЧИТАТЬ
    -- НЕ ГИБРИДНУЮ СУММУ, А ОБЫЧНУЮ И ПРИ ЧЕМ ПО НОВОМУ ПОКАЗАТЕЛЮ, ПОЭТОМУ ВСТАВИЛИ ЭТИ ДВА СЕЛЕКТА КОТОРЫЕ СТОЯТ НИЖЕ, РАНЬШЕ ИХ НЕ БЫЛО
    -- ЕСЛИ ПЕРЕИГРАЮТ, И ПРИДУТ К ВЫВОДУ, ЧТО НУЖНО ВСЕМ ДЕЛАТЬ ОДИНАКОГО ГИБРУДНУЮ СУММУ, НЕ ЗАВИСИМО БЫЛИ ЛИ ВЫПЛАТЫ ИЛИ НЕ БУЛО ВЫПЛАТ,
    -- ТО ТОГДА НУЖНО БУДЕТ УБРАТЬ ОБА СЕЛЕКТА И УСЛОВИЕ ПОСЛЕ НИХ И ОСТАВИТЬ ТОЛЬКО ВЕТКУ ELSE

    -- были ли выплаты по старому значению минимальной пенсии в текущем году
     SELECT COUNT(1)
       INTO CNT_MIN_PENS_
       FROM P_GRF G,
            P_PAYMENT_INFO I,
            WORKING_DATE W
      WHERE G.P_GRFRCT IN ( SELECT R.P_GRFRCT
                              FROM --P_CLAIM_PAY_OUT A,
                                   P_GRFRCT R
                             WHERE R.P_CONTRACT = P_CONTRACT_ --AND
                                   --R.P_CLAIM_PAY_OUT = A.P_CLAIM_PAY_OUT
                          )
        AND G.P_GRF = I.P_GRF
        AND G.IS_PAYED = 1
        AND I.STATUS = 1
        AND G.MIN_PENS_ID <> MIN_PENS_ID_
        AND W.WORKING_DATE = I.WORKING_DATE
        AND W.WORK_DATE < MIN_PENS_DATE_
        AND TO_CHAR(W.WORK_DATE,'YYYY') = TO_CHAR(DATE_,'YYYY')
        AND TO_CHAR(G.DATE_2,'YYYY') = TO_CHAR(DATE_,'YYYY');

        -- ТИМА(07.06.2017): НУЖНО ПРОВЕРИТЬ ПОМЕНЯЕТСЯ ЛИ МИНИМАЛЬНАЯ ПЕНСИЯ В БУДУЩЕМ ПО ОТНОШЕНИЮ К ТЕКУЩЕЙ ПЛАНИРУЕМОЙ ДАТЕ
        -- ЭТО НУЖНО ДЛЯ ТОГО, ЧТОБЫ ПОКРЫТЬ СЛУЧАЙ КОГДА ПРОПУСТИЛИ ПЛАНОВУЮ ВЫПЛАТУ С СТАРЫМ ПОКАЗАТЕЛЕМ, И ОПОМНИЛИСЬ СПУСТЯ НЕСКОЛЬКО МЕСЯЦЕВ, КОГДА УЖЕ ДЕЙСТВУЕТ НОВЫЙ ПОКАЗАТЕЛЬ МИН.ПЕНС.
        -- В ЭТОМ СЛУЧАЕ НАДО СЧИТАТЬ ГИБРИДНУЮ СУММУ
        -- НАПРИМЕР. ПЕРИОДИЧНОСТЬ ЕЖЕМЕСЯЧНАЯ. СЕГОДНЯ 5 АПРЕЛЯ. ПО СОСТОЯНИЮ НА СЕГОДНЯ ВЫПЛАТЫ ЗА ЯНВАРЬ И ФЕВРАЛЬ СДЕЛАЛИ, А ЗА МАРТ ЗАБЫЛИ. ПО ИДЕЕ СЕЙЧАС ДАЖЕ КОГДА РАСЧИТЫВАЕМ СУММУ К ВЫПЛАТЕ ЗА МАРТ МЫ УЖЕ ДОЛЖНЫ БРАТЬ ГИБРИДНУЮ СУММУ
        -- ЕСЛИ БЫ МЫ НЕ ПРОВЕРЯЛИ БУДУЩЕ ЗНАЧЕНИЕ МИНИМАЛЬНОЙ ПЕНСИИ, ТО У НАС БЫ ПОСЧИТАЛО НЕГИБРИДНУЮ ОБЫЧНУЮ СУММУ
        SELECT COUNT(1)
          INTO CNT_FUETURE_MIN_PENS_
          FROM G_MINIMAL_DESIGN_INDEX I
         WHERE I.G_PARAMETER = 2
           AND TO_DATE('01.'||TO_CHAR(I.K_DAY,'MM.YYYY'),'DD.MM.YYYY') > MIN_PENS_DATE_
           AND TO_CHAR(I.K_DAY,'YYYY') = TO_CHAR(DATE_,'YYYY')
           /*
           -- СОВСЕМ ЭКЗОТИЧЕСКИЙ СЛУЧАЙ:
           -- ВЫПЛАТ В ЭТОМ ГОДУ НЕ БУЛО, НО ПЕРВУЮ ВЫПЛАТУ В ЭТОМ ГОДУ БЫЛА ПРОПУЩЕНА, ХОТЯ ЭТА ПЕРВАЯ ВЫПЛАТА ВЫПАДАЛА НА СТАРЫЙ ПОКАЗАТЕЛЬ,
           -- ПОЛУЧАЕТСЯ ЭТОМУ ВКЛАДЧИКУ ПОВЕЗЛО, ФОРМАЛЬНО ВЫПЛАТ НЕ БЫЛО, И ЕМУ НУЖНО СЧИТАТЬ НЕГИБРИДНУЮ СУММУ ПО НОВОМУ ПОКАЗАТЕЛЬЮ (НЕ ПО СТАРОМУ, А ПО НОВОМУ ПОКАЗАТЕЛЮ)
           -- ПОЭТОМУ ВСТАВИЛИ ЭТОТ ПОДСЕЛЕКТ, ИНАЧЕ ЕМУ БЫ СЧИТАЛО ПО ГИБРИДНОЙ, А ЗНАЧИТ УМЕНЬШЕННОЙ СУММЕ.
           AND EXISTS (SELECT 1
                         FROM P_GRF G,
                              P_PAYMENT_INFO I,
                              WORKING_DATE W
                        WHERE G.P_GRFRCT IN ( SELECT R.P_GRFRCT
                                                FROM --P_CLAIM_PAY_OUT A,
                                                     P_GRFRCT R
                                               WHERE R.P_CONTRACT = P_CONTRACT_ --AND
                                                     --R.P_CLAIM_PAY_OUT = A.P_CLAIM_PAY_OUT
                                            )
                          AND G.P_GRF = I.P_GRF
                          AND G.IS_PAYED = 1
                          AND I.STATUS = 1
                          AND W.WORKING_DATE = I.WORKING_DATE
                          --AND G.MIN_PENS <> MIN_PENS_
                          AND W.WORK_DATE < MIN_PENS_DATE_
                          AND TO_CHAR(W.WORK_DATE,'YYYY') = TO_CHAR(DATE_,'YYYY')
                          AND TO_CHAR(G.DATE_2,'YYYY') = TO_CHAR(DATE_,'YYYY')
                       )
           */
         ;
        ----------------------

    IF CNT_MIN_PENS_ = 0 AND CNT_FUETURE_MIN_PENS_ = 0 THEN
       -- ЕСЛИ ПОСЕРЕДИНЕ ГОДА МИНИМАЛЬНАЯ ПЕНСИЯ НЕ МЕНЯЛАСЬ, ТО СЧИТАЕТСЯ ОЧЕНЬ ПРОСТО
       -- МИНИМАЛЬНУЮ ПЕНСИЮ ОПРЕДЕЛЯЕМ НА ТЕКУЩУЮ ОПЕРАЦИОННУЮ ДАТУ
       --MIN_PENS_VALUE_ := PENSION_PACK.GET_MIN_PENSION_SUMM(CURRENT_WORKING_DATE_,ERR_CODE,ERR_MSG);
       V1_   := 30 * MIN_PENS_VALUE_;

       ARR_MIN_PENS_ := ARR_MIN_PENS_TYPE();
       ARR_MIN_PENS_.EXTEND;
       ARR_MIN_PENS_(ARR_MIN_PENS_.LAST) := REC_MIN_PENS(MIN_PENS_ID_, MIN_PENS_VALUE_, MIN_PENS_DATE_,12,1,12);

       --------
    ELSE
       -- ЕСЛИ ПОСЕРЕДИНЕ ГОДА МИНИМАЛЬНАЯ ПЕНСИЯ МЕНЯЛАСЬ, ТО ГОДОВАЯ СУММА СЧИТАЕТСЯ СЛЕДУЮЩИМ ОБРАЗОМ
       -- СЧИТАЕТСЯ ПРОПОРЦИОНАЛЬНО КОЛИЧЕСТВУ МЕСЯЦЕВ. А ИМЕННО:
       --C 1 января  2014 года до 1 апреля 2014 года этот размер составлял 20 782 тенге, умножив это число на 30, получаем 623 460 тенге (годовая сумма). Делим годовую сумму на 12 и выводим сумму выплаты за три месяца финансового года (с 01.01.2014 по 31.03.2014гг.).
       --(20 782 * 30) / 12 месяцев * 3 месяца  = 155 865,00 тенге
       --С первого апреля минимальный размер пенсии составляет 21 736 тенге. Умножаем на 30 и получаем 652 080 (годовая сумма).  Делим годовую сумму на 12 и выводим сумму выплаты за девять месяцев финансового года (с 01.04.2014 по 31.12.2014 гг.).
       --(21 736 * 30) / 12 месяцев * 9 месяцев  = 489 060,00 тенге
       --Таким образом, годовая сумма выплат в части заявлений на выплату по графику, часть выплат по которым осуществлена до 01.04.2014 года, составит 644 925,00 тенге (155 865 + 489 060).

       -- 1.1 ЗАПОЛНЯЮ МАССИВ КАКИЕ ДЕЙСТВОВАЛИ МИНИМАЛЬНЫЕ ПЕНСИИ В ТЕКУЩЕМ ГОДУ
       V_I := 0;
       ARR_MIN_PENS_ := ARR_MIN_PENS_TYPE();
       ARR_MIN_PENS_.DELETE;
       FOR REC IN (
                   -- 1. ПРОШЛОЕ
                   -- ВЫТАСКИВАЕМ ПОКАЗАТЕЛИ МИНИМАЛЬНОЙ ПЕНСИИ С КОТОРЫМИ РЕАЛЬНО БЫЛИ ВЫПЛАТЫ В ЭТОМ ГОДУ,
                   -- ФАКТИЧЕСКИ МЫ ПОВТОРИЛИ ВЕРХИЙ СЕЛЕКТ КОТОРЫЙ ВЫЧИСЛЯЕТ ПЕРЕМЕННУЮ CNT_MIN_PENS_ И В НЕГО ДОБАВИЛИ СВЯЗКУ СО СПРАВОЧНИКОМ ПОКАЗАТЕЛЕЙ
                   SELECT S.G_MINIMAL_DESIGN_INDEX AS MIN_PENS_ID,
                          S.VALUE AS VAL,
                          S.K_DAY AS K_DAY
                     FROM G_MINIMAL_DESIGN_INDEX S,
                          P_GRF G,
                          P_PAYMENT_INFO I,
                          WORKING_DATE W
                    WHERE G.MIN_PENS_ID = S.G_MINIMAL_DESIGN_INDEX
                      AND G.P_GRFRCT IN ( SELECT R.P_GRFRCT
                                            FROM --P_CLAIM_PAY_OUT A,
                                                 P_GRFRCT R
                                           WHERE R.P_CONTRACT = P_CONTRACT_ --AND
                                                 --R.P_CLAIM_PAY_OUT = A.P_CLAIM_PAY_OUT
                                        )
                      AND G.P_GRF = I.P_GRF
                      AND G.IS_PAYED = 1
                      AND I.STATUS = 1
                      AND G.MIN_PENS_ID <> MIN_PENS_ID_
                      AND W.WORKING_DATE = I.WORKING_DATE
                      AND W.WORK_DATE < MIN_PENS_DATE_
                      AND TO_CHAR(W.WORK_DATE,'YYYY') = TO_CHAR(DATE_,'YYYY')
                      AND TO_CHAR(G.DATE_2,'YYYY') = TO_CHAR(DATE_,'YYYY')

                    UNION
                    -- 2. НАСТОЯЩЕЕ
                    -- ЭТО СЛУЧАЙ КОГДА ТОЛЬКО ХОТЯТ ВЫПЛАТИТЬ ВЫПЛАТУ В ЭТОМ ГОДУ
                    SELECT MIN_PENS_ID_ AS MIN_PENS_ID,
                           MIN_PENS_VALUE_ AS VAL,
                           MIN_PENS_DATE_ AS K_DAY
                    FROM DUAL

                    UNION
                    -- 3. БУДУЩЕЕ
                    -- ВЫТАСКИВАЕМ БУДУЩИЕ ИЗМЕНЕНИЯ ПОКАЗАТЕЛЕЙ МИНИМАЛЬНОЙ ПЕНСИИ В ЭТОМ ГОДУ, Т.К.
                    -- ОНИ ТОЖЕ ДОЛЖНЫ ВОЙТИ В ГИБРИДНУЮ СУММУ
                   SELECT I.G_MINIMAL_DESIGN_INDEX AS MIN_PENS_ID,
                          I.VALUE AS VAL,
                          I.K_DAY AS K_DAY
                     FROM G_MINIMAL_DESIGN_INDEX I
                     WHERE I.G_PARAMETER = 2
                       AND I.K_DAY > BASE_DATE_
                       AND TO_CHAR(I.K_DAY,'YYYY') = TO_CHAR(BASE_DATE_, 'YYYY')


                   ORDER BY 3
                   )
       LOOP
         V_I := V_I + 1;
         /*
         IF V_I = 1 AND TO_CHAR(REC.K_DAY,'DD.MM') != '01.01' THEN
            -- В НАЧАЛЕ ТЕКУЩЕГО ГОДА ДЕЙСТВОВАЛА МИНИМАЛЬНАЯ ПЕНСИЯ ПРЕДЫДУЩЕГО ГОДА
            SELECT I.VALUE,
                   1,
                   12
              INTO TMP_MIN_PENS_VAL_,
                   TMP_MIN_PENS_MONTH_BEGIN_,
                   TMP_MIN_PENS_MONTH_END_
              FROM G_MINIMAL_DESIGN_INDEX I
             WHERE I.G_PARAMETER = 2
               AND I.K_DAY = (SELECT MAX(I2.K_DAY)
                                FROM G_MINIMAL_DESIGN_INDEX I2
                               WHERE I2.G_PARAMETER = 2 AND
                                     I2.K_DAY < TO_DATE('01.01.'||TO_CHAR(DATE_,'YYYY'),'DD.MM.YYYY')
                              );
            ARR_MIN_PENS_.EXTEND(1);
            ARR_MIN_PENS_(ARR_MIN_PENS_.LAST).VAL := TMP_MIN_PENS_VAL_;
            ARR_MIN_PENS_(ARR_MIN_PENS_.LAST).MONTH_BEGIN := TMP_MIN_PENS_MONTH_BEGIN_;
            ARR_MIN_PENS_(ARR_MIN_PENS_.LAST).MONTH_END := TMP_MIN_PENS_MONTH_END_;
            -----------------------------------
         END IF;
         */

         -- ОБНОВЛЯЕМ МЕСЯЦ ОКОНЧАНИЯ ПРЕДЫДУЩЕГО ЭЛЕМЕНТА МАССИВА
         IF V_I > 1 THEN
           ARR_MIN_PENS_(ARR_MIN_PENS_.LAST).MONTH_END := TO_NUMBER(TO_CHAR(REC.K_DAY,'MM'))-1;
           IF ARR_MIN_PENS_(ARR_MIN_PENS_.LAST).MONTH_END = 0 THEN ARR_MIN_PENS_(ARR_MIN_PENS_.LAST).MONTH_END := 1; END IF;
         END IF;
         -- ЕСЛИ В ОДНОМ МЕСЯЦА МЕНЯЛСЯ НЕСКОЛЬКО РАЗ, ТО БУДЕМ БРАТЬ ТОЛЬКО ПОСЛЕДНИЙ
         IF ARR_MIN_PENS_.COUNT = 0 THEN
           ARR_MIN_PENS_.EXTEND(1);
         ELSE
             IF ARR_MIN_PENS_(ARR_MIN_PENS_.LAST).MONTH_BEGIN != TO_NUMBER(TO_CHAR(REC.K_DAY,'MM')) THEN
               ARR_MIN_PENS_.EXTEND(1);
             END IF;
         END IF;
         ---------------------
         ARR_MIN_PENS_(ARR_MIN_PENS_.LAST) := REC_MIN_PENS(NULL, NULL, NULL, NULL, NULL, NULL);--REC_MIN_PENS(MIN_PENS_ID_, MIN_PENS_VALUE_, MIN_PENS_DATE_,12,1,12);

         ARR_MIN_PENS_(ARR_MIN_PENS_.LAST).MIN_PENS_ID := REC.MIN_PENS_ID;
         ARR_MIN_PENS_(ARR_MIN_PENS_.LAST).MIN_PENS_VAL := REC.VAL;
         ARR_MIN_PENS_(ARR_MIN_PENS_.LAST).MIN_PENS_DATE := REC.K_DAY;

         IF V_I = 1 THEN
             ARR_MIN_PENS_(ARR_MIN_PENS_.LAST).MONTH_BEGIN := 1;
         ELSE
             ARR_MIN_PENS_(ARR_MIN_PENS_.LAST).MONTH_BEGIN := TO_NUMBER(TO_CHAR(REC.K_DAY,'MM'));
         END IF;
         ARR_MIN_PENS_(ARR_MIN_PENS_.LAST).MONTH_END := 12;

       END LOOP;

       IF V_I = 0 THEN
          -- В СПРАВОЧНИКЕ ВООБЩЕ НЕТ МИН.ПЕНСИИ ЗА ТЕКУЩИЙ ГОД ЗНАЧИТ ДЕЙСТВУЕТ МИНИМАЛЬНАЯ ПЕНСИЯ ПРЕДЫДУЩЕГО ГОДА
          SELECT I.G_MINIMAL_DESIGN_INDEX,
                 I.VALUE,
                 1,
                 12
            INTO TMP_MIN_PENS_ID_,
                 TMP_MIN_PENS_VAL_,
                 TMP_MIN_PENS_MONTH_BEGIN_,
                 TMP_MIN_PENS_MONTH_END_
            FROM G_MINIMAL_DESIGN_INDEX I
           WHERE I.G_PARAMETER = 2
             AND I.K_DAY = (SELECT MAX(I2.K_DAY)
                              FROM G_MINIMAL_DESIGN_INDEX I2
                             WHERE I2.G_PARAMETER = 2 AND
                                   I2.K_DAY < TO_DATE('01.01.'||TO_CHAR(DATE_,'YYYY'),'DD.MM.YYYY')
                            );
          ARR_MIN_PENS_.EXTEND(1);
          ARR_MIN_PENS_(ARR_MIN_PENS_.LAST).MIN_PENS_VAL := TMP_MIN_PENS_VAL_;
          ARR_MIN_PENS_(ARR_MIN_PENS_.LAST).MONTH_BEGIN := TMP_MIN_PENS_MONTH_BEGIN_;
          ARR_MIN_PENS_(ARR_MIN_PENS_.LAST).MONTH_END := TMP_MIN_PENS_MONTH_END_;
          -----------------------------------
       END IF;
         -- 1.1  КОНЕЦ ЗАПОЛНЕНИЯ МАССИВА

         -- 1.2 ОПРЕДЕЛЯЕМ ГИБРИДНУЮ ГОДОВУЮ СУММУ, ПУТЁМ СЛОЖЕНИЯ ВСЕХ ЭЛЕМЕНТВО МАССИВА ИЗ ПОЛЯ "VAL-ЗНАЧЕНИЕ МИН. ПЕНСИИ"
         FOR I IN 1..ARR_MIN_PENS_.COUNT LOOP
           V1_ := NVL(V1_,0) + ARR_MIN_PENS_(I).MIN_PENS_VAL * 30 / 12 * (ARR_MIN_PENS_(I).MONTH_END - ARR_MIN_PENS_(I).MONTH_BEGIN + 1);
           ARR_MIN_PENS_(I).MONTH_COUNT := ARR_MIN_PENS_(I).MONTH_END - ARR_MIN_PENS_(I).MONTH_BEGIN + 1;
         END LOOP;

    END IF;
    --V1_   := 30 * PENSION_PACK.GET_MIN_PENSION_SUMM(DATE_,ERR_CODE,ERR_MSG);
  ELSE
    -- Сарсенбаев Б.О. 26.09.2018: Если это заявление по новому законодательству (действующему с 01.01.2018)
    -- то можно вернуть массив пенсий с пустыми значениями - так как для нового законодательства минимальные пенсии не играют никакой роли
    -- (если вообще массив не заполнять - то будет ругаться в тех процедурах, которые вызывают данную функцию)
    ARR_MIN_PENS_ := ARR_MIN_PENS_TYPE();
    ARR_MIN_PENS_.EXTEND(1);
  END IF; -- конец условия IF IS_HAVE_RIGHT_REG_OLD_LAW_ != 0 THEN


   V2_   := 250000; --Вторая величина из алгоритма

   SELECT TO_NUMBER(TO_CHAR(NVL(DATE_,TRUNC(SYSDATE)),'YYYY')) - TO_NUMBER(TO_CHAR(N.DT,'YYYY'))
     INTO AGE_
     FROM P_CONTRACT P,
          G_NAT_PERSON N --(!) G_NAT_PERSON$$O N
    WHERE N.G_PERSON = P.G_PERSON_RECIPIENT AND
          P.P_CONTRACT = P_CONTRACT_;

   VIP_KOEF_ := PENSION_PACK.GET_WITHDRAW_KOEF(AGE_ ,ERR_CODE,ERR_MSG);

   V3_   := NVL(V_SUMM_,0) * VIP_KOEF_; -- третья величина из алгоритма

   -- 06-03-2021: МАМЕТОВ СЕРИК АЛИМАМЕТОВИЧ: ПО ЗАДАЧЕ В БИТРИКСЕ № 599199 РАЗРАБОТКА И РЕАЛИЗАЦИЯ ФУНКЦИОНАЛА ПО РАСЧЕТУ РАЗМЕРА ПЕНСИОННЫХ ВЫПЛАТ
   -- В СООТВЕТСТВИИ С МЕТОДИКОЙ ОСУЩЕСТВЛЕНИЯ РАСЧЕТА РАЗМЕРА ПЕНСИОННЫХ ВЫПЛАТ
   -- 1. Годовая сумма пенсионных выплат в первый год осуществления пенсионных выплат рассчитывается как произведение суммы пенсионных накоплений на ставку выплат пенсионных накоплений.
   -- - ставка выплат пенсионных накоплений - 6,5 %;
   -- Пример 1.
   -- Сумма ПН =6 000 0000 тенге
   -- Годовая сумма пенсионных выплат в первый год: 6 000 000*6,5%=390 000тенге;
   -- Размер ежемесячной пенсионной выплаты в первый го:390 000/12 мес.=32 500тенге;
   -- Размер ежемесячной пенсионной выплаты на второй год: 32 500*105%=34 125 тенге.
   -- В последующие годы осуществления пенсионных выплат размер ежемесячной пенсионной выплаты определяется путем увеличения размера ежемесячной
   -- пенсионной выплаты за предыдущий год на ставку индексации пенсионных выплат.

   -- 2.Годовая сумма пенсионных выплат в первый год осуществления пенсионных выплат умножается на поправочный коэффициент, указанный в приложении к настоящей заявке, в случае, если физическое лицо, удовлетворяет одному из следующих условий:
   -- 1) имеется инвалидность первой группы, установленная бессрочно;
   -- 2) имеется инвалидность второй группы, установленная бессрочно;
   -- 3) наступление пенсионного возраста в соответствии с пунктом 1 статьи 11 Закона и наличие пенсионных накоплений, сформированных за счет обязательных профессиональных пенсионных взносов в совокупности не менее шестидесяти месяцев.
   -- Для лиц, удовлетворяющих более чем одному из вышеуказанных условий,применяется поправочный коэффициент с наибольшим значением.
   -- Пример 2.
   -- У физического лицаимеется инвалидность первой группы, установленная бессрочно:
   -- Сумма ПН =6 000 0000 тенге
   -- Годовая сумма пенсионных выплат в первый год:
   -- 6 000 000*6,5%=390 000*0,96=374 400тенге;
   -- 0,96-поправочный  коэффициент  для возраста 31 год;
   -- Размер ежемесячной пенсионной выплаты в первый год:374 000/12= 31 200тенге;
   -- Размер ежемесячной пенсионной выплаты на второй год: 31 200*105%=32 760тенге.
   -- В последующие годы осуществления пенсионных выплат размер ежемесячной пенсионной выплаты определяется путем увеличения размера ежемесячной
   -- пенсионной выплаты за предыдущий год на ставку индексации пенсионных выплат.

   -- Пример 3.
   -- Если у физического лицаимеется инвалидность второй группы, установленная бессрочно, возраст 63 года, (1,27-поправ. коэф. по инвалидности 2 группы), также наличие пенсионных накоплений, сформированных за счет обязательных профессиональных пенсионных взносов в совокупности не менее шестидесяти месяцев(поправ коэф.1,45), то в данном случае применяется поправочный коэффициент с наибольшим значением-1,45:
   -- Сумма ПН на ОППВ =6 000 0000 тенге
   -- Годовая сумма пенсионных выплат в первый год: 6 000 000*6,5%=390 000*1,45=565 500 тенге;
   -- Размер ежемесячной пенсионной выплаты в первый год:565 500/12= 47 125тенге.
   -- Размер ежемесячной пенсионной выплатына второй год: 47 125*105%=49 481,25тенге.
   -- При наличии пенсионных накоплений на ОПВ счете, годовая сумма пенсионных выплат рассчитывается аналогично ОППВ.

   IF (TRUNC(DATE_RECEPTION_) >= TO_DATE('01.04.2021', 'DD.MM.YYYY') OR
       TRUNC(DATE_REGISTR_) >= TO_DATE('01.04.2021', 'DD.MM.YYYY')
      ) AND G_TYPE_PERIOD_ = 4 THEN
     IF DATE_ < TO_DATE('01.01.2021', 'DD.MM.YYYY') THEN
       PAYOUT_RATE_ := PENSION_PACK.GET_PAYOUT_RATE(TRUNC(DATE_RECEPTION_), V_ERR_CODE, V_ERR_MSG);
     ELSE
       PAYOUT_RATE_ := PENSION_PACK.GET_PAYOUT_RATE(TRUNC(DATE_), V_ERR_CODE, V_ERR_MSG);
     END IF;

     PAYOUT_RATE_ := PAYOUT_RATE_/100;

     IF V_ERR_CODE != 0 THEN
       ERR_CODE := -20500;
       ERR_MSG  := V_ERR_MSG;
       RAISE TYPES.E_FORCE_EXIT;
     END IF;

     V3_   := ROUND(NVL(V_SUMM_,0) * PAYOUT_RATE_, 2); -- третья величина из алгоритма
   END IF;



    -- 25.09.2018 Сарсенбаев Б.О.: Доработка по заявке №5 о определении суммы выплаты на дату обращения для заявлений по новому законодательству
    -- Для заявлений на выплату по новому законодатеьству,если остаток ПН <= 12 минимальных пенсий, то в графике должна сидеть только одна выплата
    -- на весь остаток; иначе строится обычный ежемесячный график.
    -- Остаток ПН надо сравнивать с 12 минимальными пенсиями именно по состянию на дату обращения вкладчика
    -- Выше в переменные V_SUMM_ и MIN_PENS_ON_DATE_CONCTACT_ поместил значения пенсионных накоплений и
    -- значение минимальной пенсии именно на дату обращения
    -- 07.03.2019 Маметов С.: Заявка №19545 по сопровождению о довыплатах после обнуления остатка на ИПС
    -- Если это заявление создано автоматически Айдыном как заявление на довыплату (то есть в номере заявления присуствует фраза "ДВ_график")
    -- то сравнение с 12 МЗП проводить не надо
    -- Поэтому в конец условия IF добавил AND INSTR(LOWER(Rec_claim.CLAIM_NUM),'дв_график') = 0
    IF V_IS_ON_OPER_CLAIM_DATE = 1 AND V_SUMM_<= 12 * MIN_PENS_ON_DATE_CONCTACT_ AND INSTR(LOWER(CLAIM_NUM_),'дв_график') = 0 -- выше в блоке 27 в переменную V_IS_ON_OPER_CLAIM_DATE поместил признак что надо вычислять на дату обращения
      AND NVL(PAYOUT_RATE_, 1)!=0.065 -- 25.02.2022  Бычков для довыплат по распоряжениям 2022+ года, чтобы график нормально строился
    THEN
      -- если остаток меньше, то его и возвращаю
      V3_ := V_SUMM_;
    END IF;


   /*-- По заявке на развитие №3 о передаче выплат в ГК если еще первая выплата не произошла и если текущий остаток на ИПС <= 12 мин. пенсий + 54%,
   -- то выплачиваем весь остаток, то есть годовая сумма будет равна текущему остатку. В этих случаях в качестве годовой суммы возвращаем остаток пенсионных накоплений
   -- Добавил условие AND IS_VIRTUAL_ = 0 так как если  дело дошло до вирутального остатка, то речь идет о будущем годе то есть дело дошло до следующих будущих выплат
   -- и там уже корректировать и сравнивать с 12 мин. пенсий уже не надо
   -- 17.07.2018 Задача в битриксе №211186
   -- Если это заявление на выплату инвалидам по новому законодательству, то они обрабатываются как заявления на выплату через ГК
   -- то есть они тоже должны попадать в эту ветку
   -- поэтому в условие IF добавил это условие OR (IS_HAVE_RIGHT_REG_OLD_LAW_ = 0 AND p_g_pay_out_type_ = 8 AND date_registr_ >= PENSION_PACK.DATE_REGISTR_CLAIM_PAY_NEW)
   IF (P_G_REGISTRATION_TYPE_ = 4 OR (IS_HAVE_RIGHT_REG_OLD_LAW_ = 0 AND p_g_pay_out_type_ = 8 AND date_registr_ >= PENSION_PACK.DATE_REGISTR_CLAIM_PAY_NEW)) AND IS_VIRTUAL_ = 0 THEN
      IF v_count_payed_claim_all = 0 THEN
        -- если по данному заявлению не было ни одной выплаты вообще, то остаток на текущую дату сравниваю с 12 минимальных пенсий
        -- (этот показатель беру по состоянию на Date_, например в этом году в январе происходит первая выплата вообще по заявлению, поданному
        -- в конце прошлого года, поэтому показатель беру на предыдущий год)
        IF V_SUMM_<= GET_MIN_PENSION_SUMM_IN_YEAR(DATE_)*12 THEN -- IF V_SUMM_<= GET_MIN_PENSION_SUMM_IN_YEAR(DATE_)*12 + ROUND(GET_MIN_LIVING_LEVEL(DATE_) * 0.54,2) THEN
           -- если остаток меньше, то его и возвращаю
           V3_ := V_SUMM_;
        ELSE
          -- если остаток больше, то ворзвращаю вычисленную выше годовую сумму (т.е. остаток умноженный на коэф. по возрасту)
          NULL;
        END IF;
      ELSE
        -- если по данному заявлению была хоть одна выплата вообще
        IF V_COUNT_PAY_YEAR_THIS_CLAIM = 0 THEN
          -- если в этом году не было ни одной выплаты (но по заявлению вообще была хоть одна выплата в прошлом году)
          -- то сравниваю с 12 МП (показатель берется на текущую дату)
          IF V_SUMM_<= GET_MIN_PENSION_SUMM_IN_YEAR(TRUNC(SYSDATE))*12 THEN --IF V_SUMM_<= GET_MIN_PENSION_SUMM_IN_YEAR(TRUNC(SYSDATE))*12 + ROUND(GET_MIN_LIVING_LEVEL(TRUNC(SYSDATE)) * 0.54,2) THEN
             -- если остаток меньше, то его и возвращаю
             V3_ := V_SUMM_;
          ELSE
             -- если остаток больше, то ворзвращаю вычисленную выше годовую сумму (т.е. остаток умноженный на коэф. по возрасту)
             NULL;
          END IF;
        ELSE
          -- если в этом году была хоть одна выплата
          -- то сравниваю с 12 МП (показатель берется на дату первой выплаты)

          -- вычисляю дату первой выплаты в текущем году
          SELECT MIN(I.DATE_PAY_FACT)
            INTO V_DATE_FIRST_PAY_YEAR_
            FROM MAIN.P_PAYMENT_INFO I
           WHERE --EXISTS (SELECT 1 FROM P_CLAIM_PAY_OUT PP WHERE PP.P_CLAIM_PAY_OUT_INITIAL = V_P_CLAIM_PAY_OUT_INITIAL)
                 I.P_CLAIM_PAY_OUT IN (SELECT PP.P_CLAIM_PAY_OUT FROM P_CLAIM_PAY_OUT PP WHERE PP.P_CLAIM_PAY_OUT_INITIAL = V_P_CLAIM_PAY_OUT_INITIAL)
             AND I.STATUS = 1
             AND TO_CHAR(I.DATE_2,'YYYY') = TO_CHAR(DATE_,'YYYY');

          IF V_SUMM_<= GET_MIN_PENSION_SUMM_IN_YEAR(V_DATE_FIRST_PAY_YEAR_)*12 THEN --IF V_SUMM_<= GET_MIN_PENSION_SUMM_IN_YEAR(V_DATE_FIRST_PAY_YEAR_)*12 + ROUND(GET_MIN_LIVING_LEVEL(V_DATE_FIRST_PAY_YEAR_) * 0.54,2) THEN
             -- если остаток меньше, то его и возвращаю
             V3_ := V_SUMM_;
          ELSE
             -- если остаток больше, то ворзвращаю вычисленную выше годовую сумму (т.е. остаток умноженный на коэф. по возрасту)
             NULL;
          END IF;
        END IF;
      END IF;


   END IF;*/
   ----------------------------

   IF IS_HAVE_RIGHT_REG_OLD_LAW_ = 1 THEN
     -- 06-03-2021: МАМЕТОВ СЕРИК АЛИМАМЕТОВИЧ: ПО ЗАДАЧЕ В БИТРИКСЕ № 599199 РАЗРАБОТКА И РЕАЛИЗАЦИЯ ФУНКЦИОНАЛА ПО РАСЧЕТУ РАЗМЕРА ПЕНСИОННЫХ ВЫПЛАТ
     -- В СООТВЕТСТВИИ С МЕТОДИКОЙ ОСУЩЕСТВЛЕНИЯ РАСЧЕТА РАЗМЕРА ПЕНСИОННЫХ ВЫПЛАТ. ДАЛЕЕ ИЗ ЗАДАЧИ АНАЛИЗА № 599200
     -- 1. Для лиц, реализовавших свое право на пенс.впылаты до 2018 года:
     -- по ежегодникам: годовая сумма рассчитывается в размере не менее 30 МП, т.е. начиная с момента, когда дата выплаты по графику по годовым выплатам приходится на 1 апреля,
     -- ежегодная сумма должна быть из расчета 30 МП, иначе перерасчет, (т.е. для расчета годовой  суммы не применять коэффициенты).
     -- 2.по ежемесячным и ежеквартальным рассчитанная сумма ежемесячной и ежеквартальной выплаты остается до конца года остается без изменения,
     -- в 2022 году : пенсионные выплаты осуществляются в размере не менее тридцатикратного размера минимальной пенсии, установленного на соответствующий финансовый год законом о республиканском бюджете
     -- Индексация для лиц, указанных в п.1 и 2  с 2022 г. не применяется.

     -- 19-08-2021: МАМЕТОВ СЕРИК АЛИМАМЕТОВИЧ: ПО ЗАДАЧЕ В БИТРИКСЕ № 669146 ТЕПЕРЬ ТРЕБУЕТСЯ ОТМЕНА УСЛОВИЯ НИЖЕ
     -- 1.    Департамент учета и отчетности пенсионных активов (Байгалиева З.Ж.):
     -- 1) с даты подписания акта о завершении работ и приемки в промышленную эксплуатацию доработки ИАИС-2 вкладчикам (получателям), реализовавшим свое право на пенсионные выплаты
     -- из ЕНПФ до 1 января 2018 года, пенсионные выплаты с периодичностью «ежегодно» рассчитывать согласно Методике 1, действовавшей на момент принятия заявлений
     -- о назначении пенсионных выплат, в следующем порядке:
     -- сумма годовой пенсионной выплаты рассчитывается и не превышает наибольшую из
     -- тридцатикратного размера минимальной пенсии, установленного на соответствующий финансовый год законом о республиканском бюджете;
     -- величины, рассчитанной как произведение суммы пенсионных накоплений на коэффициент текущей стоимости пенсионных накоплений в соответствующем
     -- возрасте получателя согласно Методике;
     /*IF G_TYPE_PERIOD_ = 1 THEN
       V3_ := V1_;
     END IF;*/
     RESULT := GREATEST(V1_,V2_,V3_);
   ELSE
      -- (27.11.2017) ПО ДОРАБОТКЕ НОВОГО АЛГОРИТМА ПО ЗАКОНОДАТЕЛЬСТВУ С 2018Г - ВСЕ ВИПЫ

      -- закомментарил ДЕЛЕНИе НА КОЛ-ВО ОСТАВШИХСЯ МЕСЯЦЕВ, Т.К. СНАРУЖИ В P_CALC_GRF ВЫЧИСЛЯЕТСЯ ПРЕДЫДУЩИЕ ВЫПЛАТЫ И ПОЛУЧАЕМ ОТРИЦАТЕЛЬНУЮ ГОДОВУЮ СУММУ
      -- ОПРЕДЕЛЯЕМ КОЛ-ВО ОСТАВШИХСЯ МЕСЯЦЕВ ДО КОНЦА ТЕКУЩЕГО ГОДА
      --V_I := 12 - TO_CHAR(DATE_,'MM') + 1;
      --RESULT := ROUND(V3_ / 12 * V_I, 2);



      -- ВЫЧИСЛЯЕМ ПО КАКОМУ ЗАЯВЛЕНИЮ БЫЛА ПЕРВАЯ ВЫПЛАТА В ТЕКУЩЕМ ГОДУ, ПО СТАРОМУ ЗАКОНОДАТЕЛЬСТВУ или ПО НОВОМУ С НАЧИНАЯ 2018Г.
      -- если выплата была по старому законодательству, то старая годовая сумма теоретически могла быть больше чем новая годовая сумма по новому законодательству (т.е. по ВИПу)
      -- В ЭТОМ СЛУЧАЕ НАДО ЧТОБЫ ФУНКЦИЯ ВЕРНУЛА СТАРУЮ БОЛЬШУЮ СУММУ (тем самым мы обеспечиваем фиксацию годовой суммы на начало года)
      -- Чтобы было более понятно рассмотрим конкретный пример. В начале года была выплата по старому законодательству, то есть вкладчик не был ВИП, годовая сумма была 30*МЗП
      --(то есть эти 30 МЗП были больше чем сумма ВИПа). Теперь он подал новое заявление по новому законодательству и ему соответственно выплачивается  сумма ВИПа, которая меньше чем 30 МЗП по старому заявлению.

      /* ЗАКОММЕНТАРИЛИ ВЫЧИСЛЕНИЕ МАКСИМАЛЬНОЙ СУММЫ ПО СТАРОМУ ДЕЙСТВОВАВШЕМУ ЗАЯВЛЕНИЮ ПО СТАРОМУ ЗАКОНОДАТЕЛЬСТВУ.
        ПО ДОГОВОРЕННОСТИ РЕШИЛИ, ЧТО ГОДОВАЯ СУММА БУДЕТ ПО ПОВОМУ ЗАЯВЛЕНИЮ - ВЫЧИСЛЯТЬСЯ ПО НОВОМУ ЗАКОНОДАТЕЛЬСТВУ

      IF V_P_PAYMENT_INFO_ IS NOT NULL THEN
        SELECT C.IS_HAVE_RIGHT_REGISTER_OLD_LAW
          INTO V_I
          FROM P_PAYMENT_INFO I,
               P_CLAIM_PAY_OUT C
         WHERE I.P_PAYMENT_INFO = V_P_PAYMENT_INFO_
           AND C.P_CLAIM_PAY_OUT = I.P_CLAIM_PAY_OUT;
      ELSE
          V_I := 0;
      END IF;

      IF V_I = 1 THEN
        RESULT := GREATEST(V1_,V2_,V3_);
      ELSE
      */
        RESULT := V3_;
      --END IF;
   END IF;

   IF RESULT = V3_ THEN
     IS_VIP_ := 1;
   ELSE
    IS_VIP_ := 0;
   END IF;

   -- ЕСЛИ ПЕРЕДАЕТСЯ -1, ТО НЕ ОБРЕЗАТЬ ПОЛОЖЕННУЮ СУММУ
   IF (IGNORE_REMAIN_ = 0) THEN
       NULL;
   ELSE
       SELECT COUNT(*)
         INTO V_COUNT
         FROM P_CLAIM_PAY_OUT R
        WHERE R.P_CONTRACT = P_CONTRACT_ AND
              R.P_G_CLAIM_PAY_OUT_KND = 4 AND
              -- 18.05.2018: ПО ЗАЯВКЕ №4 2018, В РАМКАХ ДОРАБОТКИ ПЕРЕДАЧИ ВЫПЛАТ ГК, ДЛЯ ЗАЯВЛЕНИЙ ПОЛУЧЕННЫХ ИЗ ГК НАДО СТРОИТЬ ГРАФИК ОТ ДАТЫ ПРИЁМА ЗАЯВЛЕНИЯ, А НЕ ОТ ДАТЫ РЕГИСТРАЦИИ
              --TO_CHAR(DECODE(R.P_G_REGISTRATION_TYPE,4,R.DATE_RECEPTION,R.DATE_REGISTR),'YYYY') = TO_CHAR(DATE_,'YYYY')
              TO_CHAR(
              DECODE(R.P_G_REGISTRATION_TYPE,4,
              -- если в заявлениях ГК дата приема заявления сидит в будущих годах (такое может быть т.к. в качестве даты приема указывается дата достижения вкладчиком пенсионного возраста)
              -- то в дате приема заявления заменяем будущий год на текщуий год
              CASE WHEN TO_CHAR(R.DATE_RECEPTION,'YYYY') > TO_CHAR(SYSDATE,'YYYY') THEN TO_DATE(TO_CHAR(R.DATE_RECEPTION,'dd.mm.')||TO_CHAR(SYSDATE,'YYYY'),'dd.mm.yyyy')
              ---------------
              ELSE R.DATE_RECEPTION END,
              R.DATE_REGISTR),'YYYY')
              = TO_CHAR(DATE_,'YYYY')
              ;

       IF V_COUNT = 0 THEN
           -- Тима(17.02.2012): Раушан сказала, что при выплатах в операциях в графе "годовая сумма к выплате"
           -- должна отображаться не максимально положенная, а сколько есть на ИПС(если меньше).
           -- Айдын эту сумму хранит в заявлении.
           IF (SUMM_REMAIN_ < RESULT) THEN
             RESULT := SUMM_REMAIN_;
           END IF;
       END IF;
   END IF;

   RETURN RESULT;

EXCEPTION
  WHEN TYPES.E_Force_Exit THEN
    ERR_CODE := V_ERR_CODE;
    ERR_MSG  := PROCNUM || ' 00 ' || ADM.ERROR_PACK.GET_ERR_MSG('0000', ERR_CODE, V_ERR_MSG)|| ' BLOCK_='||BLOCK_;
  WHEN OTHERS THEN
    ERR_CODE := SQLCODE;
    ERR_MSG  := PROCNUM || ' 00 ' || ADM.ERROR_PACK.GET_ERR_MSG('0000', ERR_CODE, SQLERRM)|| ' BLOCK_='||BLOCK_;
END P_GET_RECIPIENT_SUMM_YEAR_HYBR;
/
